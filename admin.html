<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Coffee Posts Admin</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Space Grotesk', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background: #0a0a0a;
            color: #ffffff;
            line-height: 1.6;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 2rem;
        }

        .header {
            text-align: center;
            margin-bottom: 2rem;
        }

        .header h1 {
            color: #d4a574;
            margin-bottom: 0.5rem;
        }

        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 1rem;
            margin-bottom: 2rem;
        }

        .stat-card {
            background: #1a1a1a;
            padding: 1rem;
            border-radius: 8px;
            text-align: center;
        }

        .stat-number {
            font-size: 2rem;
            color: #d4a574;
            font-weight: bold;
        }

        .controls {
            display: flex;
            gap: 1rem;
            margin-bottom: 2rem;
            flex-wrap: wrap;
        }

        .search-box, .filter-select {
            padding: 0.5rem;
            border: 1px solid #2a2a2a;
            border-radius: 4px;
            background: #1a1a1a;
            color: #ffffff;
            flex: 1;
            min-width: 200px;
        }

        .btn {
            padding: 0.5rem 1rem;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.9rem;
            transition: background 0.3s ease;
        }

        .btn-primary {
            background: #d4a574;
            color: #000;
        }

        .btn-primary:hover {
            background: #c49660;
        }

        .btn-danger {
            background: #dc3545;
            color: white;
        }

        .btn-danger:hover {
            background: #c82333;
        }

        .btn-secondary {
            background: #2a2a2a;
            color: white;
        }

        .btn-secondary:hover {
            background: #3a3a3a;
        }

        .posts-grid {
            display: grid;
            gap: 1rem;
        }

        /* Grouping styles */
        .continent-group {
            margin-bottom: 2rem;
            position: relative;
        }

        .continent-header {
            font-size: 1.8rem;
            font-weight: bold;
            color: #D4A574;
            margin-bottom: 1rem;
            padding: 1rem 1.5rem;
            border-bottom: 3px solid #D4A574;
            text-transform: uppercase;
            letter-spacing: 2px;
            position: sticky;
            top: 0;
            background: linear-gradient(to bottom, #0a0a0a 0%, #0a0a0a 90%, rgba(10, 10, 10, 0.95) 100%);
            z-index: 100;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(10px);
            display: flex;
            align-items: center;
            gap: 1rem;
        }

        .continent-header::before {
            content: "üåç";
            font-size: 1.5rem;
        }

        .country-group {
            margin-bottom: 1.5rem;
            margin-left: 1rem;
            position: relative;
        }

        .country-header {
            font-size: 1.4rem;
            font-weight: 600;
            color: #C0C0C0;
            margin-bottom: 0.75rem;
            padding: 0.75rem 1rem;
            border-bottom: 2px solid #4a4a4a;
            background: linear-gradient(to bottom, #1a1a1a 0%, #1a1a1a 90%, rgba(26, 26, 26, 0.95) 100%);
            position: sticky;
            top: 60px;
            z-index: 90;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
            backdrop-filter: blur(8px);
            display: flex;
            align-items: center;
            gap: 0.75rem;
        }

        .country-header::before {
            content: "üèõÔ∏è";
            font-size: 1.1rem;
        }

        .city-group {
            margin-bottom: 1rem;
            margin-left: 1rem;
            position: relative;
        }

        .city-header {
            font-size: 1.1rem;
            font-weight: 500;
            color: #9A9A9A;
            margin-bottom: 0.5rem;
            padding: 0.5rem 0.75rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
            background: #252525;
            position: sticky;
            top: 120px;
            z-index: 80;
            border-left: 3px solid #D4A574;
            box-shadow: 0 1px 4px rgba(0, 0, 0, 0.2);
        }

        .city-header::before {
            content: "üìç";
            font-size: 0.9rem;
        }

        .city-posts {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(320px, 1fr));
            gap: 1rem;
            margin-left: 1rem;
            padding-top: 0.5rem;
        }

        .post-card {
            background: #1a1a1a;
            border-radius: 8px;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        .post-hero-image {
            position: relative;
            width: 100%;
            aspect-ratio: 16 / 9;
            overflow: hidden;
        }

        .post-hero-image img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .post-images {
            width: 120px;
            display: flex;
            flex-wrap: wrap;
            gap: 4px;
        }

        .post-thumbnail {
            width: 56px;
            height: 56px;
            object-fit: cover;
            border-radius: 4px;
            border: 1px solid #2a2a2a;
        }

        .post-content {
            padding: 1rem;
            flex: 1;
        }

        .post-title {
            font-size: 1.1rem;
            margin-bottom: 0.5rem;
            color: #d4a574;
        }

        .post-meta {
            font-size: 0.9rem;
            color: #a0a0a0;
            margin-bottom: 0.5rem;
        }

        .post-description {
            color: #ffffff;
            margin-bottom: 0.5rem;
        }

        .post-actions {
            padding: 1rem;
            padding-top: 0;
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
        }

        .inline-rating {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            flex-wrap: wrap;
        }

        .rating-label {
            color: #a0a0a0;
            font-size: 0.9rem;
            margin-right: 0.25rem;
        }

        .rating-star {
            background: none;
            border: 2px solid #444;
            color: #666;
            font-size: 1.1rem;
            padding: 4px 6px;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s ease;
            line-height: 1;
        }

        .rating-star:hover {
            border-color: #d4a574;
            color: #d4a574;
            background: rgba(212, 165, 116, 0.1);
        }

        .rating-star.active {
            border-color: #d4a574;
            color: #d4a574;
            background: rgba(212, 165, 116, 0.2);
        }

        .current-rating {
            color: #d4a574;
            font-weight: bold;
            font-size: 0.9rem;
            margin-left: 0.25rem;
        }

        .action-buttons {
            display: flex;
            gap: 0.5rem;
            flex-wrap: wrap;
        }

        .image-count {
            position: absolute;
            bottom: 8px;
            right: 8px;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 12px;
        }

        .post-description {
            color: #a0a0a0;
            line-height: 1.5;
            margin-top: 0.5rem;
        }

        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            z-index: 1000;
        }

        .modal-content {
            background: #1a1a1a;
            width: 100vw;
            height: 100vh;
            padding: 2rem;
            border-radius: 0;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 2rem;
            flex-shrink: 0;
        }

        #post-form {
            flex: 1;
            display: flex;
            flex-direction: column;
            max-width: 800px;
            margin: 0 auto;
            width: 100%;
        }

        .close {
            background: none;
            border: none;
            font-size: 1.5rem;
            color: #a0a0a0;
            cursor: pointer;
        }

        /* Image Modal Styles */
        .image-modal-content {
            position: relative;
            background: none;
            border: none;
            border-radius: 0;
            padding: 2rem;
            display: flex;
            align-items: center;
            justify-content: center;
            width: 100%;
            height: 100%;
        }

        .image-modal-close {
            position: absolute;
            top: 2rem;
            right: 2rem;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            border: none;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            font-size: 24px;
            cursor: pointer;
            z-index: 1001;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background 0.3s ease;
        }

        .image-modal-close:hover {
            background: rgba(0, 0, 0, 0.9);
        }

        #modal-image {
            max-width: 90vw;
            max-height: 90vh;
            object-fit: contain;
            border-radius: 8px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
        }

        .image-tile img {
            cursor: pointer;
            transition: transform 0.2s ease;
        }

        .image-tile img:hover {
            transform: scale(1.05);
        }

        .form-group {
            margin-bottom: 1rem;
        }

        .form-group label {
            display: block;
            margin-bottom: 0.5rem;
            color: #d4a574;
        }

        .form-group input, .form-group textarea, .form-group select {
            width: 100%;
            padding: 0.5rem;
            border: 1px solid #2a2a2a;
            border-radius: 4px;
            background: #0a0a0a;
            color: #ffffff;
        }

        .form-group textarea {
            height: 80px;
            resize: vertical;
        }

        .images-list {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
            gap: 1rem;
            margin-bottom: 2rem;
            padding: 1rem;
            background: #0a0a0a;
            border-radius: 8px;
            max-height: none;
        }

        .image-item {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.5rem;
            border-bottom: 1px solid #2a2a2a;
        }

        .image-item img {
            width: 40px;
            height: 40px;
            object-fit: cover;
            border-radius: 4px;
        }

        .image-item input {
            flex: 1;
            margin: 0;
        }

        .image-tile {
            display: flex;
            flex-direction: column;
            background: #1a1a1a;
            border-radius: 8px;
            overflow: hidden;
            border: 1px solid #2a2a2a;
            position: relative;
            cursor: move;
            transition: all 0.3s ease;
        }

        .image-tile.dragging {
            opacity: 0.5;
            transform: scale(0.95);
        }

        .image-tile.drag-over {
            border-color: #d4a574;
            box-shadow: 0 0 10px rgba(212, 165, 116, 0.3);
        }

        .drag-handle {
            position: absolute;
            top: 8px;
            right: 8px;
            background: rgba(0, 0, 0, 0.8);
            color: #d4a574;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 16px;
            font-weight: bold;
            line-height: 1;
            cursor: move;
            z-index: 10;
            user-select: none;
            opacity: 0.8;
            transition: opacity 0.2s ease;
        }

        .image-tile:hover .drag-handle {
            opacity: 1;
        }

        .image-position-indicator {
            position: absolute;
            top: 8px;
            left: 8px;
            background: rgba(0, 0, 0, 0.8);
            color: #ffffff;
            padding: 4px 8px;
            border-radius: 12px;
            font-size: 12px;
            font-weight: bold;
            line-height: 1;
            z-index: 10;
            user-select: none;
            min-width: 20px;
            text-align: center;
        }

        .image-tile img {
            width: 100%;
            height: 120px;
            object-fit: cover;
        }

        .image-tile-controls {
            padding: 0.5rem;
            display: flex;
            flex-direction: column;
            gap: 0.25rem;
        }

        .image-tile input {
            padding: 0.25rem;
            border: 1px solid #2a2a2a;
            border-radius: 4px;
            background: #0a0a0a;
            color: #ffffff;
            font-size: 0.8rem;
        }

        .image-tile .remove-btn {
            background: #dc3545;
            color: white;
            border: none;
            padding: 0.25rem;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.8rem;
        }

        .image-tile .remove-btn:hover {
            background: #c82333;
        }

        .add-image-btn {
            grid-column: 1 / -1;
            padding: 2rem;
            background: #1a1a1a;
            color: #a0a0a0;
            border: 2px dashed #2a2a2a;
            border-radius: 8px;
            cursor: pointer;
            text-align: center;
            transition: all 0.3s ease;
            font-size: 1.1rem;
        }

        .add-image-btn:hover {
            background: #2a2a2a;
            border-color: #d4a574;
            color: #d4a574;
        }

        .location-suggestions {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            background: #2a2a2a;
            border: 1px solid #3a3a3a;
            border-radius: 8px;
            max-height: 400px;
            overflow-y: auto;
            z-index: 1000;
            display: none;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
        }

        .location-suggestions.searching {
            display: block;
        }

        .search-indicator {
            padding: 1rem;
            text-align: center;
            color: #d4a574;
            font-size: 0.9rem;
        }

        .search-indicator::before {
            content: "üîç";
            margin-right: 0.5rem;
        }
        
        .search-error {
            padding: 1rem;
            text-align: center;
            color: #f44336;
            font-size: 0.9rem;
            background: rgba(244, 67, 54, 0.1);
            border-radius: 8px;
            border: 1px solid rgba(244, 67, 54, 0.2);
        }

        .suggestion-category {
            background: #1a1a1a;
            padding: 0.5rem 1rem;
            font-size: 0.8rem;
            font-weight: 600;
            color: #d4a574;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            border-bottom: 1px solid #3a3a3a;
        }

        .location-suggestion {
            padding: 0.75rem 1rem;
            cursor: pointer;
            border-bottom: 1px solid #333;
            transition: all 0.2s ease;
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
        }

        .location-suggestion:hover {
            background: #3a3a3a;
            transform: translateX(2px);
        }

        .location-suggestion:last-child {
            border-bottom: none;
        }

        .suggestion-content {
            flex: 1;
        }

        .suggestion-name {
            font-weight: 500;
            color: #ffffff;
            font-size: 0.95rem;
            margin-bottom: 0.25rem;
        }

        .suggestion-address {
            font-size: 0.8rem;
            color: #d4a574;
            margin-bottom: 0.35rem;
            line-height: 1.3;
            font-style: italic;
        }
        .suggestion-details {
            font-size: 0.8rem;
            color: #a0a0a0;
            line-height: 1.3;
        }

        .suggestion-coords {
            font-size: 0.75rem;
            color: #666;
            text-align: right;
            margin-left: 1rem;
            min-width: 100px;
        }

        .business-type {
            background: #d4a574;
            color: #1a1a1a;
            padding: 0.125rem 0.375rem;
            border-radius: 3px;
            font-size: 0.7rem;
            font-weight: 500;
            margin-right: 0.5rem;
            display: inline-block;
        }

        .location-info {
            color: #a0a0a0;
        }

        .cafe-suggestion {
            border-left: 3px solid #d4a574;
        }

        .cafe-suggestion .suggestion-name {
            color: #d4a574;
        }

        .cafe-suggestion:hover {
            background: #3a2e26;
        }

        .location-search-container {
            position: relative;
        }

        #location-search {
            padding-right: 2.5rem;
        }
        .geocode-preview-container {
            margin-top: 1rem;
            padding: 1rem;
            background: #1a1a1a;
            border: 1px solid #2a2a2a;
            border-radius: 8px;
        }
        .geocode-info {
            margin-bottom: 1rem;
        }
        .geocode-info h4 {
            color: #d4a574;
            margin-bottom: 0.5rem;
            font-size: 1rem;
        }
        .geocode-info p {
            color: #a0a0a0;
            font-size: 0.85rem;
            margin-bottom: 0.25rem;
        }
        #geocode-coords {
            font-family: monospace;
            color: #666;
        }

        .search-status {
            position: absolute;
            right: 0.75rem;
            top: 50%;
            transform: translateY(-50%);
            font-size: 0.8rem;
            color: #a0a0a0;
        }

        .search-status.searching {
            color: #d4a574;
        }

        .search-status.searching::after {
            content: "...";
            animation: dots 1.5s steps(5, end) infinite;
        }

        .search-status.success {
            color: #4CAF50;
        }

        .search-status.error {
            color: #f44336;
        }

        .search-status.warning {
            color: #ff9800;
        }

        @keyframes dots {
            0%, 20% { content: "."; }
            40% { content: ".."; }
            60% { content: "..."; }
            90%, 100% { content: ""; }
        }

        .form-group {
            position: relative;
        }

        .loading {
            text-align: center;
            padding: 2rem;
            color: #a0a0a0;
        }

        .tabs {
            display: flex;
            border-bottom: 1px solid #2a2a2a;
            margin-bottom: 1rem;
        }

        .tab {
            padding: 0.75rem 1.5rem;
            background: none;
            border: none;
            color: #a0a0a0;
            cursor: pointer;
            border-bottom: 2px solid transparent;
        }

        .tab.active {
            color: #d4a574;
            border-bottom-color: #d4a574;
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        /* Map positioning for mobile */
        @media (max-width: 768px) {
            .post-card {
                grid-template-columns: 1fr;
            }
            
            .controls {
                flex-direction: column;
            }
            
            /* Modal content styling for mobile */
            .modal[style*="block"] .modal-content {
                max-height: calc(100vh - 2rem);
                overflow-y: auto;
            }
            
        }
        
        /* Site Header Toolbar Styles */
        .site-header {
            position: sticky;
            top: 0;
            background: rgba(10, 10, 10, 0.95);
            backdrop-filter: blur(10px);
            z-index: 1000;
            border-bottom: 1px solid var(--border-color);
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        }

        .nav-container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 0 2rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            height: 70px;
        }

        .site-title {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            text-decoration: none;
            color: var(--primary-color);
            transition: color 0.3s ease;
        }

        .site-title:hover {
            color: var(--accent-color);
        }

        .coffee-icon {
            font-size: 1.5rem;
            filter: drop-shadow(0 2px 4px rgba(212, 165, 116, 0.3));
        }

        .title-content {
            display: flex;
            flex-direction: column;
        }

        .main-title {
            font-size: 1.2rem;
            font-weight: 600;
            margin: 0;
            line-height: 1.2;
        }

        .nav-links {
            display: flex;
            align-items: center;
            gap: 2rem;
        }

        .nav-links a {
            text-decoration: none;
            color: var(--text-light);
            font-weight: 500;
            font-size: 0.95rem;
            padding: 0.5rem 1rem;
            border-radius: 4px;
            transition: all 0.2s ease;
        }

        .nav-links a:hover,
        .nav-links a.current {
            color: var(--accent-color);
            background: rgba(212, 165, 116, 0.1);
        }

        .instagram-icon {
            width: 20px;
            height: 20px;
        }

        .burger-menu {
            display: none;
            background: none;
            border: none;
            color: var(--primary-color);
            font-size: 1.5rem;
            cursor: pointer;
            padding: 0.5rem;
        }

        .mobile-nav {
            position: fixed;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100vh;
            background: var(--bg-color);
            transition: left 0.3s ease;
            z-index: 1001;
            padding: 2rem;
            display: flex;
            flex-direction: column;
            gap: 2rem;
        }

        .mobile-nav.open {
            left: 0;
        }

        .close-btn {
            align-self: flex-end;
            background: none;
            border: none;
            color: var(--primary-color);
            font-size: 2rem;
            cursor: pointer;
            padding: 0.5rem;
            margin-bottom: 1rem;
        }

        .mobile-nav a {
            text-decoration: none;
            color: var(--primary-color);
            font-size: 1.2rem;
            font-weight: 500;
            padding: 1rem 0;
            border-bottom: 1px solid var(--border-color);
            transition: color 0.2s ease;
        }

        .mobile-nav a:hover,
        .mobile-nav a.current {
            color: var(--accent-color);
        }

        @media (max-width: 768px) {
            .nav-container {
                padding: 0 1rem;
            }
            
            .nav-links {
                display: none;
            }
            
            .burger-menu {
                display: block;
            }
            
            .main-title {
                font-size: 1rem;
            }
        }

        /* Adjust container for toolbar */
        .container {
            margin-top: 2rem;
        }

        /* Mobile scroll disable */
        .mobile-scroll-disabled {
            position: fixed;
            width: 100%;
            height: 100%;
            overflow: hidden;
        }
    </style>
    
    <!-- Leaflet CSS and JS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    
    <!-- Google Maps Places API (for location search) -->
    <script>
        // Initialize Google Maps Places service
        let googleMapsReady = false;
        
        async function initGoogleMaps() {
            googleMapsReady = true;
            console.log('Google Maps API initialized');
        }
        
        // Set your API key here - YOU MUST REPLACE THIS
        const GOOGLE_MAPS_API_KEY = 'AIzaSyAU-6iLL4pyuj5wA6SwgYa5wPlPMR6jkxk';
    </script>
    <script async defer src="https://maps.googleapis.com/maps/api/js?key=AIzaSyAU-6iLL4pyuj5wA6SwgYa5wPlPMR6jkxk&libraries=places&callback=initGoogleMaps&loading=async"></script>
</head>
<body>
    <header class="site-header">
        <nav class="nav-container">
            <a href="/" class="site-title">
                <span class="coffee-icon">‚òï</span>
                <div class="title-content no-breadcrumb">
                    <h1 class="main-title">World Coffee Tour</h1>
                </div>
            </a>
            <div class="nav-links">
                <a href="/">The Tour</a>
                <a href="/admin.html" class="current">Admin</a>
                <a href="/about">About</a>
                <a href="https://instagram.com/joegaudet" target="_blank" rel="noopener">
                    <svg class="instagram-icon" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <rect x="2" y="2" width="20" height="20" rx="5" ry="5"></rect>
                        <path d="M16 11.37A4 4 0 1 1 12.63 8 4 4 0 0 1 16 11.37z"></path>
                        <line x1="17.5" y1="6.5" x2="17.51" y2="6.5"></line>
                    </svg>
                </a>
            </div>
            <button class="burger-menu" id="burger-menu">‚ò∞</button>
        </nav>
        
        <!-- Mobile Navigation -->
        <nav class="mobile-nav" id="mobile-nav">
            <button class="close-btn" id="close-mobile-nav">√ó</button>
            <a href="/">The Tour</a>
            <a href="/admin.html" class="current">Admin</a>
            <a href="/about">About</a>
            <a href="https://instagram.com/joegaudet" target="_blank" rel="noopener">Instagram</a>
        </nav>
    </header>

    <div class="container">
        <div class="header">
            <h1>‚òï Coffee Posts Admin</h1>
            <p>Database-driven content management</p>
        </div>

        <div class="stats" id="stats">
            <div class="stat-card">
                <div class="stat-number" id="total-posts">-</div>
                <div>Total Posts</div>
            </div>
            <div class="stat-card">
                <div class="stat-number" id="published-posts">-</div>
                <div>Published</div>
            </div>
            <div class="stat-card">
                <div class="stat-number" id="unrated-posts">-</div>
                <div>Unrated</div>
            </div>
            <div class="stat-card">
                <div class="stat-number" id="needs-polish-posts">-</div>
                <div>Needs Polish</div>
            </div>
            <div class="stat-card">
                <div class="stat-number" id="problematic-posts">-</div>
                <div>Problematic</div>
            </div>
        </div>

        <div class="controls">
            <input type="text" class="search-box" id="search" placeholder="Search posts...">
            <button class="btn btn-secondary" onclick="regeneratePosts()">Regenerate Jekyll Posts</button>
        </div>

        <div class="tabs">
            <button class="tab active" onclick="switchTab('published')">Published</button>
            <button class="tab" onclick="switchTab('unrated')">Unrated</button>
            <button class="tab" onclick="switchTab('needs-polish')">Needs Polish</button>
            <button class="tab" onclick="switchTab('problematic')">Problematic</button>
        </div>

        <div class="tab-content active" id="published-content">
            <div class="posts-grid" id="published-posts-grid"></div>
        </div>


        <div class="tab-content" id="unrated-content">
            <div class="posts-grid" id="unrated-posts-grid"></div>
        </div>

        <div class="tab-content" id="needs-polish-content">
            <div class="posts-grid" id="needs-polish-posts-grid"></div>
        </div>

        <div class="tab-content" id="problematic-content">
            <div class="posts-grid" id="problematic-posts-grid"></div>
        </div>

        <div class="loading" id="loading">Loading posts...</div>
    </div>

    <!-- Edit Modal -->
    <div class="modal" id="edit-modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2 id="modal-title">Edit Post</h2>
                <button class="close" onclick="closeModal()">&times;</button>
            </div>
            
            <form id="post-form">
                <input type="hidden" id="post-id">
                
                <div class="form-group">
                    <label for="title">Title</label>
                    <input type="text" id="title" required>
                </div>
                
                <div class="form-group">
                    <label for="description">Description</label>
                    <textarea id="description"></textarea>
                </div>
                
                <div class="form-group">
                    <label>Images</label>
                    <div class="images-list" id="images-list"></div>
                    <button type="button" onclick="addImageField()">Add Image</button>
                </div>
                
                <div class="form-group">
                    <label for="date">Date</label>
                    <input type="date" id="date" required>
                </div>
                
                <div class="form-group">
                    <label for="cafe-name">Cafe Name</label>
                    <input type="text" id="cafe-name">
                </div>
                
                <div class="form-group">
                    <label for="location-search">Location Search</label>
                    <div class="location-search-container">
                        <input type="text" id="location-search" placeholder="Type city, country, address, or paste Google Maps URL...">
                        <div class="search-status" id="search-status"></div>
                        <div id="location-suggestions" class="location-suggestions"></div>
                    </div>
                    <div id="geocode-preview-container" class="geocode-preview-container" style="display: none;">
                        <div class="geocode-info">
                            <h4 id="geocode-location-name">Selected Location</h4>
                            <p id="geocode-address">Address will appear here</p>
                            <p id="geocode-coords">Coordinates: --</p>
                        </div>
                        <div id="geocode-preview-map" style="height: 200px; border: 1px solid #2a2a2a; border-radius: 8px; background: #1a1a1a;"></div>
                    </div>
                </div>
                
                <div class="form-group">
                    <label for="city">City</label>
                    <input type="text" id="city">
                </div>
                
                <div class="form-group">
                    <label for="country">Country</label>
                    <input type="text" id="country">
                </div>
                
                <div class="form-group">
                    <label for="continent">Continent</label>
                    <select id="continent">
                        <option value="">Select Continent</option>
                        <option value="North America">North America</option>
                        <option value="South America">South America</option>
                        <option value="Europe">Europe</option>
                        <option value="Asia">Asia</option>
                        <option value="Africa">Africa</option>
                        <option value="Oceania">Oceania</option>
                    </select>
                </div>
                
                <div class="form-group">
                    <label for="latitude">Latitude</label>
                    <input type="number" id="latitude" step="any">
                </div>
                
                <div class="form-group">
                    <label for="longitude">Longitude</label>
                    <input type="number" id="longitude" step="any">
                </div>
                
                <div class="form-group">
                    <label for="rating">Rating</label>
                    <select id="rating">
                        <option value="">Select Rating</option>
                        <option value="1">1 ‚òï</option>
                        <option value="2">2 ‚òï‚òï</option>
                        <option value="3">3 ‚òï‚òï‚òï</option>
                        <option value="4">4 ‚òï‚òï‚òï‚òï</option>
                        <option value="5">5 ‚òï‚òï‚òï‚òï‚òï</option>
                        <option value="6">5+ ‚òï‚òï‚òï‚òï‚òï+</option>
                    </select>
                </div>
                
                
                <div style="display: flex; gap: 1rem; margin-top: 2rem;">
                    <button type="submit" class="btn btn-primary">Save Changes</button>
                    <button type="button" class="btn btn-danger" onclick="deletePost()">Delete Post</button>
                    <button type="button" class="btn btn-secondary" onclick="closeModal()">Cancel</button>
                </div>
            </form>
        </div>
    </div>

    <!-- Image Modal -->
    <div class="modal" id="image-modal" onclick="closeImageModal()">
        <div class="image-modal-content" onclick="event.stopPropagation()">
            <span class="image-modal-close" onclick="closeImageModal()">&times;</span>
            <img id="modal-image" src="" alt="Full size image">
        </div>
    </div>

    <script>
        const API_BASE = 'http://localhost:8081/api';
        let allPosts = [];
        let currentPost = null;
        let previewMap = null;
        let previewMapMarker = null;

        // Check if post is problematic (missing required data)
        function isProblematic(post) {
            return !post.cafe_name || 
                   !post.city || post.city === 'Unknown' ||
                   !post.country || post.country === 'Unknown' ||
                   !post.latitude || !post.longitude ||
                   !post.continent;
        }
        
        function needsPolish(post) {
            // Posts that have basic info but could use some polish
            if (isProblematic(post) || (!post.rating || post.rating === '' || post.rating == 0)) {
                return false; // Already covered by other categories
            }
            
            // Posts that need polish have rating and basic location but are missing refinements
            const hasShortNotes = !post.notes || post.notes.length < 50;
            const hasNoCoordinates = !post.latitude || !post.longitude;
            const hasNoInstagramUrl = !post.instagram_url || post.instagram_url === '';
            const hasGenericCafeName = post.cafe_name && (
                post.cafe_name.toLowerCase().includes('coffee') ||
                post.cafe_name.toLowerCase().includes('cafe') ||
                post.cafe_name.toLowerCase().includes('starbucks') ||
                post.cafe_name.toLowerCase() === 'unknown'
            );
            
            // A post needs polish if it has 2 or more of these issues
            const issues = [hasShortNotes, hasNoCoordinates, hasNoInstagramUrl, hasGenericCafeName].filter(Boolean).length;
            return issues >= 2;
        }

        // Advanced location search with OpenStreetMap Nominatim
        let searchTimeout;
        let currentSearchController;
        
        function setupLocationSearch() {
            const searchInput = document.getElementById('location-search');
            const suggestionsDiv = document.getElementById('location-suggestions');
            const searchStatus = document.getElementById('search-status');
            
            if (!searchInput || !suggestionsDiv || !searchStatus) return;
            
            searchInput.addEventListener('input', function(e) {
                const query = e.target.value.trim();
                
                // Cancel previous search
                if (currentSearchController) {
                    currentSearchController.abort();
                }
                clearTimeout(searchTimeout);
                
                if (query.length < 2) {
                    hideSuggestions();
                    return;
                }
                
                // Check if input is a Google Maps/Places URL
                if (isGoogleMapsUrl(query)) {
                    showSearching();
                    searchTimeout = setTimeout(async () => {
                        await handleGoogleMapsUrl(query);
                    }, 100); // Faster for URL parsing
                    return;
                }
                
                // Show searching indicator for regular search
                showSearching();
                
                searchTimeout = setTimeout(async () => {
                    await performLocationSearch(query);
                }, 500);
            });
            
            // Hide suggestions when clicking outside
            document.addEventListener('click', function(e) {
                const container = searchInput.closest('.location-search-container');
                if (!container.contains(e.target)) {
                    hideSuggestions();
                }
            });
            
            // Clear search on escape
            searchInput.addEventListener('keydown', function(e) {
                if (e.key === 'Escape') {
                    // Check if image modal is open first - don't interfere with it
                    const imageModal = document.getElementById('image-modal');
                    if (imageModal && imageModal.style.display === 'block') {
                        return; // Let the global handler deal with the image modal
                    }
                    
                    // Check if suggestions are actually visible before handling
                    const suggestionsDiv = document.getElementById('location-suggestions');
                    if (suggestionsDiv && suggestionsDiv.style.display !== 'none' && 
                        suggestionsDiv.innerHTML.trim() !== '') {
                        e.stopPropagation();
                        hideSuggestions();
                    }
                }
            });
        }
        
        function isGoogleMapsUrl(input) {
            // Check for various Google Maps URL formats
            const googleMapsPatterns = [
                /maps\.google\./,                    // maps.google.com
                /google\.[a-z]+\/maps/,              // google.com/maps
                /goo\.gl\/maps/,                     // goo.gl/maps shortlinks
                /maps\.app\.goo\.gl/,                // New Google Maps app links
                /plus\.codes/,                       // Plus codes
                /@-?\d+\.\d+,-?\d+\.\d+/,           // Coordinates pattern
                /\/place\/[^\/]+\//,                 // Place URLs
                /\/search\/[^\/]+\//,                // Search URLs
                /maps\.google\.[a-z]+.*\/place\//,   // International Google Maps place URLs
                /www\.google\.[a-z]+\/maps\/place\//,// Full place URLs
                /data=![0-9a-z!]+/i,                 // Data parameter format
                /1s0x[0-9a-f]+:[0-9a-fx]+/i         // Place ID in hex format
            ];
            
            return googleMapsPatterns.some(pattern => pattern.test(input));
        }
        
        function decodeHexPlaceId(hexPlaceId) {
            try {
                // Google's hex place IDs like "0x60188d1dd146c245:0x53e0643b30af938a" 
                // or "0x0:0x2d8135d837707e22" (single coordinate encoding)
                const parts = hexPlaceId.split(':');
                if (parts.length === 2) {
                    const hex1 = parts[0];
                    const hex2 = parts[1];
                    
                    console.log('Decoding place ID:', hexPlaceId);
                    console.log('Hex parts:', hex1, hex2);
                    
                    // Handle special case where one part is 0x0
                    if (hex1 === '0x0' && hex2 !== '0x0') {
                        // Single coordinate encoding - only second part contains data
                        const int2 = hexToSignedInt64(hex2);
                        if (int2 !== null) {
                            // For single coordinate encoding, try different algorithms
                            console.log('Single coordinate encoding detected, int value:', int2);
                            
                            // This is a common pattern for specific place IDs
                            // The exact algorithm is proprietary, but we can try known patterns
                            return tryDecodeFromSingleHex(int2, hex2);
                        }
                    } else if (hex2 === '0x0' && hex1 !== '0x0') {
                        // Single coordinate encoding - only first part contains data
                        const int1 = hexToSignedInt64(hex1);
                        if (int1 !== null) {
                            console.log('Single coordinate encoding detected, int value:', int1);
                            return tryDecodeFromSingleHex(int1, hex1);
                        }
                    } else {
                        // Dual coordinate encoding
                        const int1 = hexToSignedInt64(hex1);
                        const int2 = hexToSignedInt64(hex2);
                        
                        if (int1 !== null && int2 !== null) {
                            return tryDecodeDualCoordinates(int1, int2);
                        }
                    }
                    
                    console.log('Could not decode coordinates from place ID:', hexPlaceId);
                    return null;
                }
                return null;
            } catch (error) {
                console.error('Error decoding hex place ID:', error);
                return null;
            }
        }
        
        function tryDecodeDualCoordinates(int1, int2) {
            // Google uses a specific encoding for coordinates
            // The exact formula is proprietary, but we can approximate
            
            // Method 1: Try treating as direct coordinate encoding
            let lat = int2 / 1e7;
            let lng = int1 / 1e7;
            
            if (Math.abs(lat) <= 90 && Math.abs(lng) <= 180) {
                console.log(`Decoded coordinates (dual method 1): ${lat}, ${lng}`);
                return { lat: lat, lng: lng };
            }
            
            // Method 2: Try different scaling factor
            lat = int2 / 1e6;
            lng = int1 / 1e6;
            
            if (Math.abs(lat) <= 90 && Math.abs(lng) <= 180) {
                console.log(`Decoded coordinates (dual method 2): ${lat}, ${lng}`);
                return { lat: lat, lng: lng };
            }
            
            // Method 3: Try with offset and different scaling
            const GOOGLE_OFFSET = 0x100000000;
            lat = (int2 - GOOGLE_OFFSET) / 1e7;
            lng = (int1 - GOOGLE_OFFSET) / 1e7;
            
            if (Math.abs(lat) <= 90 && Math.abs(lng) <= 180) {
                console.log(`Decoded coordinates (dual method 3): ${lat}, ${lng}`);
                return { lat: lat, lng: lng };
            }
            
            return null;
        }
        
        function tryDecodeFromSingleHex(intValue, hexValue) {
            // For place IDs like 0x0:0x2d8135d837707e22
            // The single hex value contains encoded lat/lng information
            
            console.log('Attempting single hex decode for:', hexValue, 'int:', intValue);
            
            // Method 1: Try to extract lat/lng from the 64-bit integer
            // Some place IDs encode both coordinates in a single 64-bit value
            const high32 = Math.floor(intValue / 0x100000000);
            const low32 = intValue % 0x100000000;
            
            let lat = high32 / 1e7;
            let lng = low32 / 1e7;
            
            if (Math.abs(lat) <= 90 && Math.abs(lng) <= 180) {
                console.log(`Decoded coordinates (single method 1): ${lat}, ${lng}`);
                return { lat: lat, lng: lng };
            }
            
            // Method 2: Try different bit splitting
            const upper = (intValue >> 32) & 0xFFFFFFFF;
            const lower = intValue & 0xFFFFFFFF;
            
            lat = upper / 1e7;
            lng = lower / 1e7;
            
            if (Math.abs(lat) <= 90 && Math.abs(lng) <= 180) {
                console.log(`Decoded coordinates (single method 2): ${lat}, ${lng}`);
                return { lat: lat, lng: lng };
            }
            
            // Method 3: Try with different scaling and signed conversion
            lat = ((intValue >> 32) | 0) / 1e7; // Force signed 32-bit
            lng = ((intValue & 0xFFFFFFFF) | 0) / 1e7; // Force signed 32-bit
            
            if (Math.abs(lat) <= 90 && Math.abs(lng) <= 180) {
                console.log(`Decoded coordinates (single method 3): ${lat}, ${lng}`);
                return { lat: lat, lng: lng };
            }
            
            console.log('Could not decode single hex coordinate');
            return null;
        }
        
        function hexToSignedInt64(hexString) {
            try {
                // Remove 0x prefix if present
                const hex = hexString.replace('0x', '');
                
                // Convert to BigInt for 64-bit precision
                const bigInt = BigInt('0x' + hex);
                
                // Convert to signed 64-bit integer
                const maxInt64 = BigInt('0x7FFFFFFFFFFFFFFF');
                const minInt64 = BigInt('-0x8000000000000000');
                
                if (bigInt > maxInt64) {
                    // Handle unsigned to signed conversion
                    return Number(bigInt - BigInt('0x10000000000000000'));
                } else {
                    return Number(bigInt);
                }
            } catch (error) {
                console.error('Error converting hex to signed int64:', error);
                return null;
            }
        }
        
        function extractLocationFromGoogleUrl(url) {
            const locationInfo = {
                name: null,
                address: null,
                coordinates: null,
                placeId: null
            };
            
            try {
                // Extract coordinates from URL (most reliable)
                // Handle @lat,lng,zoom format (more common)
                let coordMatch = url.match(/@(-?\d+\.\d+),(-?\d+\.\d+),\d+/);
                if (coordMatch) {
                    locationInfo.coordinates = {
                        lat: parseFloat(coordMatch[1]),
                        lng: parseFloat(coordMatch[2])
                    };
                } else {
                    // Handle @lat,lng format (without zoom)
                    coordMatch = url.match(/@(-?\d+\.\d+),(-?\d+\.\d+)/);
                    if (coordMatch) {
                        locationInfo.coordinates = {
                            lat: parseFloat(coordMatch[1]),
                            lng: parseFloat(coordMatch[2])
                        };
                    }
                }
                
                // Extract place name from various URL formats
                let nameMatch = null;
                
                // Format: /place/Name+Here/ or /place/Name%20Here/ or /place/Name/
                nameMatch = url.match(/\/place\/([^\/\?&@]+)/);
                if (nameMatch) {
                    let placeName = decodeURIComponent(nameMatch[1]).replace(/\+/g, ' ');
                    // Clean up common artifacts
                    placeName = placeName.replace(/\s+/g, ' ').trim();
                    locationInfo.name = placeName;
                    console.log('Extracted place name:', placeName);
                }
                
                // Format: /search/Name+Here/
                if (!locationInfo.name) {
                    nameMatch = url.match(/\/search\/([^\/\?&@]+)/);
                    if (nameMatch) {
                        locationInfo.name = decodeURIComponent(nameMatch[1]).replace(/\+/g, ' ');
                    }
                }
                
                // Format: search query parameter
                if (!locationInfo.name) {
                    try {
                        const urlObj = new URL(url);
                        const query = urlObj.searchParams.get('q') || urlObj.searchParams.get('query');
                        if (query) {
                            locationInfo.name = decodeURIComponent(query);
                        }
                    } catch (urlError) {
                        // URL might be malformed, continue with other extraction methods
                    }
                }
                
                // Format: data parameter (some Google Maps URLs use this)
                if (!locationInfo.name) {
                    const dataMatch = url.match(/!3d(-?\d+\.\d+)!4d(-?\d+\.\d+)/);
                    if (dataMatch && !locationInfo.coordinates) {
                        locationInfo.coordinates = {
                            lat: parseFloat(dataMatch[1]),
                            lng: parseFloat(dataMatch[2])
                        };
                    }
                }
                
                // Extract place ID from various formats
                let placeIdMatch = url.match(/place_id:([a-zA-Z0-9_-]+)/);
                if (placeIdMatch) {
                    locationInfo.placeId = placeIdMatch[1];
                } else {
                    // Try to extract from hex format like 1s0x60188d1dd146c245:0x53e0643b30af938a
                    placeIdMatch = url.match(/1s(0x[0-9a-f]+:[0-9a-fx]+)/i);
                    if (placeIdMatch) {
                        locationInfo.placeId = placeIdMatch[1];
                        
                        // Try to decode hex place ID to coordinates
                        const coords = decodeHexPlaceId(placeIdMatch[1]);
                        if (coords) {
                            locationInfo.coordinates = coords;
                            console.log('Decoded coordinates from place ID:', coords);
                        }
                    }
                }
                
                return locationInfo;
                
            } catch (error) {
                console.error('Error parsing Google Maps URL:', error);
                return locationInfo;
            }
        }
        
        async function handleGoogleMapsUrl(url) {
            try {
                const locationInfo = extractLocationFromGoogleUrl(url);
                console.log('Extracted location info:', locationInfo);
                
                // Always prioritize coordinates if we have them (from @lat,lng or decoded place ID)
                if (locationInfo.coordinates) {
                    console.log('Using coordinates directly from URL:', locationInfo.coordinates);
                    // Use reverse geocoding to get detailed address information
                    await reverseGeocode(locationInfo.coordinates.lat, locationInfo.coordinates.lng, locationInfo.name);
                    return; // Stop here - don't fall back to search
                }
                
                // If no coordinates but we have a clear business name, use that
                if (locationInfo.name) {
                    console.log('No coordinates found, using business name for search:', locationInfo.name);
                    await performLocationSearch(locationInfo.name);
                    return;
                }
                
                // Last resort: extract business name from URL and search
                throw new Error('Could not extract coordinates or clear business name from the Google Maps URL');
                
            } catch (error) {
                console.error('Error handling Google Maps URL:', error);
                showError('Could not extract location information from this Google Maps URL. Please try copying the business name directly.');
            }
        }
        
        async function searchByPlaceInfo(locationInfo, originalUrl) {
            try {
                // If we can't extract clear information, try to extract business name from URL path
                let searchTerm = null;
                
                // Try to extract from the place path
                const pathMatch = originalUrl.match(/\/place\/([^\/\?&]+)/);
                if (pathMatch) {
                    let fullName = decodeURIComponent(pathMatch[1]).replace(/\+/g, ' ');
                    console.log('Full extracted name:', fullName);
                    
                    // If it looks like "Business+location+type", try just the first part
                    if (fullName.includes(' ')) {
                        const parts = fullName.split(' ');
                        // Try the first word first (likely the business name)
                        searchTerm = parts[0];
                        console.log('Trying first part of name:', searchTerm);
                    } else {
                        searchTerm = fullName;
                    }
                }
                
                if (searchTerm) {
                    console.log('Searching for business name:', searchTerm);
                    await performLocationSearch(searchTerm);
                } else {
                    throw new Error('Could not extract searchable information from the URL');
                }
                
            } catch (error) {
                console.error('Error searching by place info:', error);
                showError('Could not extract location information from this Google Maps URL format. Please try copying the business name directly.');
            }
        }
        
        async function reverseGeocode(lat, lng, placeName = null) {
            try {
                // Use Nominatim for reverse geocoding
                const response = await fetch(
                    `https://nominatim.openstreetmap.org/reverse?lat=${lat}&lon=${lng}&format=json&addressdetails=1&accept-language=en`,
                    { 
                        signal: currentSearchController?.signal,
                        headers: {
                            'User-Agent': 'WorldCoffeeTour-Admin/1.0'
                        }
                    }
                );
                
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}`);
                }
                
                const data = await response.json();
                
                if (data && data.lat && data.lon) {
                    // Create a result object similar to regular search results
                    const result = {
                        lat: parseFloat(data.lat),
                        lon: parseFloat(data.lon),
                        display_name: data.display_name || `${lat.toFixed(4)}, ${lng.toFixed(4)}`,
                        address: data.address || {},
                        boundingbox: data.boundingbox
                    };
                    
                    // Use the provided place name if available, otherwise use the geocoded name
                    const displayName = placeName || result.display_name;
                    console.log('Reverse geocode result:', {
                        providedName: placeName,
                        geocodedName: result.display_name,
                        finalName: displayName,
                        coordinates: `${lat}, ${lng}`
                    });
                    
                    // Update the search input to show the place name
                    document.getElementById('location-search').value = displayName;
                    
                    // Fill the form with location data
                    fillLocationFromNominatim(result);
                    
                    // Show preview
                    showGeocodePreview(result, displayName);
                    
                    // Clear suggestions
                    hideSuggestions();
                    
                    // Show success message
                    const searchStatus = document.getElementById('search-status');
                    searchStatus.textContent = '‚úì Location found from Google Maps URL';
                    searchStatus.className = 'search-status success';
                    
                } else {
                    throw new Error('Invalid response from geocoder');
                }
                
            } catch (error) {
                console.error('Reverse geocoding failed:', error);
                // Fallback to regular search if we have a place name
                if (placeName) {
                    await performLocationSearch(placeName);
                } else {
                    showError('Could not find location information for the provided coordinates.');
                }
            }
        }
        
        function showSearching() {
            const suggestionsDiv = document.getElementById('location-suggestions');
            const searchStatus = document.getElementById('search-status');
            
            searchStatus.textContent = 'Searching';
            searchStatus.className = 'search-status searching';
            
            suggestionsDiv.innerHTML = '<div class="search-indicator">üîç Searching locations...</div>';
            suggestionsDiv.className = 'location-suggestions searching';
        }
        
        function showError(message) {
            const suggestionsDiv = document.getElementById('location-suggestions');
            const searchStatus = document.getElementById('search-status');
            
            searchStatus.textContent = '‚úó Error';
            searchStatus.className = 'search-status error';
            
            suggestionsDiv.innerHTML = `<div class="search-error">‚ö†Ô∏è ${message}</div>`;
            suggestionsDiv.className = 'location-suggestions error';
        }
        
        function hideSuggestions() {
            const suggestionsDiv = document.getElementById('location-suggestions');
            const searchStatus = document.getElementById('search-status');
            
            suggestionsDiv.style.display = 'none';
            suggestionsDiv.className = 'location-suggestions';
            searchStatus.textContent = '';
            searchStatus.className = 'search-status';
        }
        
        async function performLocationSearch(query) {
            try {
                // Cancel previous request
                if (currentSearchController) {
                    currentSearchController.abort();
                }
                
                currentSearchController = new AbortController();
                
                // Try multiple search providers in order of preference
                const results = await searchWithMultipleProviders(query);
                
                if (results.length > 0) {
                    showCategorizedSuggestions(results, results.provider);
                } else {
                    // Try a fallback search if all providers fail
                    await tryFallbackSearch(query);
                }
                
            } catch (error) {
                if (error.name !== 'AbortError') {
                    console.error('Location search error:', error);
                    showSearchError();
                }
            }
        }
        
        async function searchWithMultipleProviders(query) {
            const providers = [
                {
                    name: 'Google Places',
                    search: searchWithGooglePlaces
                },
                {
                    name: 'Photon',
                    search: searchWithPhoton
                },
                {
                    name: 'Nominatim', 
                    search: searchWithNominatim
                }
            ];
            
            for (const provider of providers) {
                try {
                    console.log(`Searching with ${provider.name}...`);
                    const results = await provider.search(query);
                    if (results.length > 0) {
                        console.log(`${provider.name} found ${results.length} results`);
                        results.provider = provider.name;
                        return results;
                    }
                } catch (error) {
                    console.log(`${provider.name} search failed:`, error);
                }
            }
            
            console.log('All providers failed to find results');
            return [];
        }
        
        async function searchWithGooglePlaces(query) {
            if (!googleMapsReady) {
                console.log('Google Maps not ready, falling back');
                return [];
            }
            
            try {
                // Use the new Places API searchByText method
                const { Place } = await google.maps.importLibrary("places");
                const { AdvancedMarkerElement } = await google.maps.importLibrary("marker");
                
                const request = {
                    textQuery: query,
                    fields: ['displayName', 'location', 'formattedAddress', 'businessStatus', 'types'],
                    includedType: 'cafe',
                    maxResultCount: 10,
                    language: 'en',
                    region: 'us'
                };
                
                const { places } = await Place.searchByText(request);
                
                if (!places || places.length === 0) {
                    // Try without type restriction
                    delete request.includedType;
                    const response = await Place.searchByText(request);
                    if (!response.places || response.places.length === 0) {
                        console.log('No Google Places results found');
                        return [];
                    }
                    places = response.places;
                }
                
                // Convert to our format
                return places.map(place => {
                    const addressParts = place.formattedAddress ? place.formattedAddress.split(', ') : [];
                    const country = addressParts[addressParts.length - 1] || '';
                    const city = addressParts[addressParts.length - 3] || addressParts[addressParts.length - 2] || '';
                    
                    return {
                        place_id: `google_${place.id || Math.random()}`,
                        lat: place.location?.lat()?.toString() || '0',
                        lon: place.location?.lng()?.toString() || '0',
                        display_name: `${place.displayName}, ${place.formattedAddress}`,
                        address: {
                            amenity: place.displayName,
                            city: city,
                            country: country
                        },
                        extratags: {
                            amenity: place.types?.includes('cafe') ? 'cafe' : null
                        },
                        namedetails: {
                            name: place.displayName
                        },
                        name: place.displayName
                    };
                });
            } catch (error) {
                console.error('Google Places search error:', error);
                return [];
            }
        }
        
        async function searchWithPhoton(query) {
            const url = `https://photon.komoot.io/api/?q=${encodeURIComponent(query)}&limit=10`;
            
            const response = await fetch(url, {
                signal: currentSearchController.signal,
                headers: {
                    'User-Agent': 'WorldCoffeeTour-Admin/1.0'
                }
            });
            
            if (!response.ok) {
                throw new Error(`HTTP ${response.status}`);
            }
            
            const data = await response.json();
            
            // Convert Photon GeoJSON format to Nominatim format
            return data.features.map(feature => ({
                place_id: `photon_${feature.properties.osm_type}_${feature.properties.osm_id}`,
                lat: feature.geometry.coordinates[1].toString(),
                lon: feature.geometry.coordinates[0].toString(), 
                display_name: buildDisplayName(feature.properties),
                address: {
                    amenity: feature.properties.name,
                    house_number: feature.properties.housenumber,
                    road: feature.properties.street,
                    neighbourhood: feature.properties.locality,
                    city: feature.properties.city,
                    state: feature.properties.state,
                    postcode: feature.properties.postcode,
                    country: feature.properties.country,
                    country_code: feature.properties.countrycode
                },
                extratags: {
                    amenity: feature.properties.osm_value === 'cafe' ? 'cafe' : null
                },
                namedetails: {
                    name: feature.properties.name
                },
                name: feature.properties.name
            }));
        }
        
        function buildDisplayName(props) {
            const parts = [];
            if (props.name) parts.push(props.name);
            if (props.housenumber && props.street) parts.push(`${props.housenumber} ${props.street}`);
            else if (props.street) parts.push(props.street);
            if (props.locality) parts.push(props.locality);
            if (props.city && props.city !== props.locality) parts.push(props.city);
            if (props.state) parts.push(props.state);
            if (props.country) parts.push(props.country);
            return parts.join(', ');
        }
        
        async function searchWithNominatim(query) {
            const url = `https://nominatim.openstreetmap.org/search?` + 
                `q=${encodeURIComponent(query)}&` +
                `format=json&` +
                `limit=20&` +
                `addressdetails=1&` +
                `extratags=1&` +
                `namedetails=1&` +
                `dedupe=1`;
            
            const response = await fetch(url, {
                signal: currentSearchController.signal,
                headers: {
                    'User-Agent': 'WorldCoffeeTour-Admin/1.0'
                }
            });
            
            if (!response.ok) {
                throw new Error(`HTTP ${response.status}`);
            }
            
            return await response.json();
        }
        
        function showCategorizedSuggestions(results, provider) {
            const suggestionsDiv = document.getElementById('location-suggestions');
            const searchStatus = document.getElementById('search-status');
            
            const providerText = provider ? ` via ${provider}` : '';
            searchStatus.textContent = `${results.length} found${providerText}`;
            searchStatus.className = 'search-status success';
            
            // Categorize results
            const categories = categorizeResults(results);
            
            suggestionsDiv.innerHTML = '';
            
            // Render each category
            Object.entries(categories).forEach(([categoryName, items]) => {
                if (items.length === 0) return;
                
                // Category header
                const categoryDiv = document.createElement('div');
                categoryDiv.className = 'suggestion-category';
                categoryDiv.textContent = categoryName;
                suggestionsDiv.appendChild(categoryDiv);
                
                // Category items
                items.forEach(result => {
                    const suggestion = createLocationSuggestion(result);
                    suggestionsDiv.appendChild(suggestion);
                });
            });
            
            suggestionsDiv.style.display = 'block';
            suggestionsDiv.className = 'location-suggestions';
        }
        
        function categorizeResults(results) {
            const categories = {
                'Cafes & Coffee Shops': [],
                'Restaurants & Bars': [],
                'Points of Interest': [],
                'Cities': [],
                'Towns & Villages': [],
                'Neighborhoods': [],
                'Other': []
            };
            
            results.forEach(result => {
                const type = result.type;
                const addressType = result.addresstype;
                const placeType = result.class;
                const name = result.display_name?.toLowerCase() || '';
                const tags = result.extratags || {};
                const amenity = tags.amenity;
                const cuisine = tags.cuisine;
                
                // Prioritize cafes and coffee shops at the top
                if (amenity === 'cafe' || 
                    name.includes('coffee') || name.includes('cafe') || name.includes('caf√©') ||
                    cuisine === 'coffee_shop' ||
                    tags.name?.toLowerCase().includes('coffee') ||
                    tags.name?.toLowerCase().includes('cafe')) {
                    categories['Cafes & Coffee Shops'].push(result);
                } else if (['restaurant', 'bar', 'pub', 'fast_food'].includes(amenity) ||
                          placeType === 'amenity' && ['restaurant', 'bar', 'pub', 'fast_food'].includes(type)) {
                    categories['Restaurants & Bars'].push(result);
                } else if (['tourism', 'amenity', 'leisure'].includes(placeType) ||
                          ['attraction', 'museum', 'hotel'].includes(amenity)) {
                    categories['Points of Interest'].push(result);
                } else if (['city', 'administrative'].includes(type) || 
                    ['city'].includes(addressType) ||
                    result.place_rank <= 16) {
                    categories['Cities'].push(result);
                } else if (['town', 'village', 'hamlet', 'municipality'].includes(type) ||
                          ['town', 'village', 'hamlet'].includes(addressType)) {
                    categories['Towns & Villages'].push(result);
                } else if (['suburb', 'neighbourhood', 'residential', 'quarter'].includes(type) ||
                          ['suburb', 'neighbourhood'].includes(addressType)) {
                    categories['Neighborhoods'].push(result);
                } else {
                    categories['Other'].push(result);
                }
            });
            
            return categories;
        }
        
        function createLocationSuggestion(result) {
            const suggestion = document.createElement('div');
            suggestion.className = 'location-suggestion';
            
            const name = result.display_name;
            const address = result.address || {};
            const tags = result.extratags || {};
            const nameDetails = result.namedetails || {};
            const lat = parseFloat(result.lat);
            const lng = parseFloat(result.lon);
            
            // Extract meaningful location info
            const city = address.city || address.town || address.village || address.municipality || '';
            const state = address.state || address.province || address.region || '';
            const country = address.country || '';
            
            // Get business name if available
            let businessName = '';
            if (nameDetails.name) {
                businessName = nameDetails.name;
            } else if (tags.name) {
                businessName = tags.name;
            } else if (result.name) {
                businessName = result.name;
            } else {
                businessName = name.split(',')[0].trim();
            }
            
            // Determine business type
            const amenity = tags.amenity;
            const shop = tags.shop;
            let businessType = '';
            let isCafe = false;
            
            if (amenity === 'cafe' || shop === 'coffee') {
                businessType = '‚òï Cafe';
                isCafe = true;
            } else if (amenity === 'restaurant') {
                businessType = 'üçΩÔ∏è Restaurant';
                // Check if it's coffee-related
                if (businessName.toLowerCase().includes('coffee') || 
                    businessName.toLowerCase().includes('cafe') || 
                    businessName.toLowerCase().includes('espresso')) {
                    businessType = '‚òï Coffee Restaurant';
                    isCafe = true;
                }
            } else if (amenity === 'fast_food') {
                businessType = 'üçî Fast Food';
            } else if (shop) {
                businessType = `üõçÔ∏è ${shop.charAt(0).toUpperCase() + shop.slice(1)} Shop`;
            }
            
            // Create clean display name
            let displayName = businessName.length > 60 ? 
                businessName.substring(0, 57) + '...' : businessName;
            
            // Highlight cafe results
            if (isCafe) {
                suggestion.classList.add('cafe-suggestion');
            }
            
            // Create full address for display
            const fullAddress = result.display_name || [businessName, city, state, country].filter(x => x).join(', ');
            
            suggestion.innerHTML = `
                <div class="suggestion-content">
                    <div class="suggestion-name">${displayName}</div>
                    <div class="suggestion-address">${fullAddress}</div>
                    <div class="suggestion-details">
                        ${businessType ? `<span class="business-type">${businessType}</span>` : ''}
                        <span class="location-info">${[city, state, country].filter(x => x).join(', ')}</span>
                    </div>
                </div>
                <div class="suggestion-coords">
                    ${lat.toFixed(4)}<br>
                    ${lng.toFixed(4)}
                </div>
            `;
            
            suggestion.addEventListener('click', () => {
                document.getElementById('location-search').value = businessName;
                fillLocationFromNominatim(result);
                showGeocodePreview(result, businessName);
                hideSuggestions();
            });
            
            return suggestion;
        }
        
        function fillLocationFromNominatim(result) {
            const address = result.address || {};
            const lat = parseFloat(result.lat);
            const lng = parseFloat(result.lon);
            const tags = result.extratags || {};
            const nameDetails = result.namedetails || {};
            const amenity = tags.amenity;
            const shop = tags.shop;
            
            // Extract location components
            const city = address.city || address.town || address.village || address.municipality || '';
            const country = address.country || '';
            const continent = getContinentFromCountry(country);
            
            // Determine business name with better logic
            let businessName = '';
            
            // First check for explicit name in namedetails or tags
            if (nameDetails.name) {
                businessName = nameDetails.name;
            } else if (tags.name) {
                businessName = tags.name;
            } else if (result.name) {
                businessName = result.name;
            } else {
                // Fall back to first part of display_name
                businessName = result.display_name.split(',')[0].trim();
            }
            
            // Check if this is a cafe/coffee business using multiple criteria
            const isCafe = amenity === 'cafe' || 
                          amenity === 'restaurant' ||
                          shop === 'coffee' ||
                          tags.cuisine === 'coffee_shop' ||
                          businessName.toLowerCase().includes('coffee') || 
                          businessName.toLowerCase().includes('cafe') || 
                          businessName.toLowerCase().includes('caf√©') ||
                          businessName.toLowerCase().includes('espresso') ||
                          businessName.toLowerCase().includes('roaster') ||
                          businessName.toLowerCase().includes('bean');
            
            // Fill basic location fields
            document.getElementById('city').value = city;
            document.getElementById('country').value = country;
            document.getElementById('latitude').value = lat;
            document.getElementById('longitude').value = lng;
            
            // Handle title and cafe name based on business type
            if (isCafe && businessName) {
                // For cafes, use the business name for both title and cafe name
                document.getElementById('title').value = businessName;
                document.getElementById('cafe-name').value = businessName;
            } else if (businessName && businessName !== city && businessName !== country) {
                // For other businesses or specific places, still set title
                document.getElementById('title').value = businessName;
                // Don't set cafe-name for non-cafe businesses
            }
            
            // Set continent dropdown
            const continentSelect = document.getElementById('continent');
            if (continent && continentSelect) {
                console.log('Setting continent:', continent);
                continentSelect.value = continent;
            } else {
                console.log('No continent found for country:', country);
            }
            
            console.log('Filled location data:', {
                businessName,
                isCafe,
                amenity,
                shop,
                city,
                country,
                lat,
                lng
            });
        }
        
        function getContinentFromCountry(country) {
            const continentMap = {
                // North America
                'United States': 'North America', 'Canada': 'North America', 'Mexico': 'North America',
                'Guatemala': 'North America', 'Honduras': 'North America', 'Nicaragua': 'North America',
                
                // South America  
                'Brazil': 'South America', 'Argentina': 'South America', 'Chile': 'South America',
                'Colombia': 'South America', 'Peru': 'South America', 'Ecuador': 'South America',
                'Venezuela': 'South America', 'Bolivia': 'South America', 'Uruguay': 'South America',
                
                // Europe
                'United Kingdom': 'Europe', 'France': 'Europe', 'Germany': 'Europe', 'Italy': 'Europe',
                'Spain': 'Europe', 'Netherlands': 'Europe', 'Belgium': 'Europe', 'Sweden': 'Europe',
                'Norway': 'Europe', 'Denmark': 'Europe', 'Finland': 'Europe', 'Switzerland': 'Europe',
                'Austria': 'Europe', 'Poland': 'Europe', 'Czech Republic': 'Europe', 'Hungary': 'Europe',
                
                // Asia
                'Japan': 'Asia', 'China': 'Asia', 'India': 'Asia', 'South Korea': 'Asia', 'Thailand': 'Asia',
                'Vietnam': 'Asia', 'Indonesia': 'Asia', 'Malaysia': 'Asia', 'Singapore': 'Asia',
                'Philippines': 'Asia', 'Taiwan': 'Asia',
                
                // Oceania
                'Australia': 'Oceania', 'New Zealand': 'Oceania', 'Fiji': 'Oceania',
                
                // Africa
                'South Africa': 'Africa', 'Egypt': 'Africa', 'Morocco': 'Africa', 'Kenya': 'Africa',
                'Nigeria': 'Africa', 'Ghana': 'Africa'
            };
            
            return continentMap[country] || '';
        }
        
        async function tryFallbackSearch(originalQuery) {
            const words = originalQuery.toLowerCase().split(' ');
            
            // Quick city/country detection for common locations
            let fallbackQuery = null;
            
            // Check for Santiago, Chile specifically (most common case)
            if (words.includes('santiago') && words.includes('chile')) {
                fallbackQuery = 'Santiago, Chile';
            } else if (words.includes('santiago')) {
                fallbackQuery = 'Santiago, Chile';
            }
            // Add other common locations as needed
            else if (words.includes('buenos') && words.includes('aires')) {
                fallbackQuery = 'Buenos Aires, Argentina';
            } else if (words.includes('mexico') && words.includes('city')) {
                fallbackQuery = 'Mexico City, Mexico';
            }
            
            // Only try one fast fallback search
            if (fallbackQuery) {
                try {
                    const results = await searchWithNominatim(fallbackQuery);
                    if (results.length > 0) {
                        showFallbackResults(results.slice(0, 3), originalQuery, fallbackQuery); // Limit to 3 results
                        return;
                    }
                } catch (error) {
                    console.log('Fallback search failed:', error);
                }
            }
            
            // If fallback fails or no city detected, show no results immediately
            showNoResults();
        }
        
        function showFallbackResults(results, originalQuery, fallbackQuery) {
            const suggestionsDiv = document.getElementById('location-suggestions');
            const searchStatus = document.getElementById('search-status');
            
            searchStatus.textContent = `No exact match for "${originalQuery}" - showing results for "${fallbackQuery}"`;
            searchStatus.className = 'search-status warning';
            
            suggestionsDiv.innerHTML = `
                <div class="search-indicator">
                    <strong>No exact match found for "${originalQuery}"</strong><br>
                    Showing nearby locations in ${fallbackQuery}:<br>
                    <small>Select a location below and manually enter the business name.</small>
                </div>
            `;
            
            results.forEach(result => {
                const suggestion = createLocationSuggestion(result);
                suggestionsDiv.appendChild(suggestion);
            });
            
            suggestionsDiv.style.display = 'block';
        }

        function showNoResults() {
            const suggestionsDiv = document.getElementById('location-suggestions');
            const searchStatus = document.getElementById('search-status');
            
            searchStatus.textContent = 'No results found';
            searchStatus.className = 'search-status error';
            
            suggestionsDiv.innerHTML = `
                <div class="search-indicator">
                    <strong>No locations found</strong><br>
                    This business may not be mapped in OpenStreetMap yet.<br><br>
                    <strong>Try:</strong><br>
                    ‚Ä¢ Search for the city/area instead (e.g., "Santiago, Chile")<br>
                    ‚Ä¢ Try a different business name or address<br>
                    ‚Ä¢ Fill in the location details manually below<br><br>
                    <em>Many small businesses aren't yet in mapping databases.</em>
                </div>
            `;
            suggestionsDiv.style.display = 'block';
        }
        
        function showSearchError() {
            const suggestionsDiv = document.getElementById('location-suggestions');
            const searchStatus = document.getElementById('search-status');
            
            searchStatus.textContent = 'Error';
            searchStatus.className = 'search-status';
            
            suggestionsDiv.innerHTML = `
                <div class="search-indicator">
                    Search temporarily unavailable. Please fill location fields manually.
                </div>
            `;
            suggestionsDiv.style.display = 'block';
        }
        
        function showGeocodePreview(result, businessName) {
            const previewContainer = document.getElementById('geocode-preview-container');
            const locationName = document.getElementById('geocode-location-name');
            const address = document.getElementById('geocode-address');
            const coords = document.getElementById('geocode-coords');
            const mapContainer = document.getElementById('geocode-preview-map');
            
            const lat = parseFloat(result.lat);
            const lng = parseFloat(result.lon);
            const displayName = result.display_name || businessName;
            
            // Update info
            locationName.textContent = businessName || 'Selected Location';
            address.textContent = displayName;
            coords.textContent = `Coordinates: ${lat.toFixed(6)}, ${lng.toFixed(6)}`;
            
            // Show container
            previewContainer.style.display = 'block';
            
            // Initialize or update map
            setTimeout(() => {
                if (!previewMap) {
                    previewMap = L.map('geocode-preview-map').setView([lat, lng], 15);
                    
                    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                        attribution: '¬© OpenStreetMap contributors'
                    }).addTo(previewMap);
                    
                    previewMapMarker = L.marker([lat, lng])
                        .addTo(previewMap)
                        .bindPopup(businessName || 'Selected Location');
                } else {
                    previewMap.setView([lat, lng], 15);
                    previewMapMarker.setLatLng([lat, lng]);
                    previewMapMarker.setPopupContent(businessName || 'Selected Location');
                    previewMap.invalidateSize();
                }
            }, 100);
        }
        
        function hideGeocodePreview() {
            const previewContainer = document.getElementById('geocode-preview-container');
            previewContainer.style.display = 'none';
            
            if (previewMap) {
                previewMap.remove();
                previewMap = null;
                previewMapMarker = null;
            }
        }

        // Load initial data
        document.addEventListener('DOMContentLoaded', function() {
            initializeFromQueryString(); // Set up correct tab from URL
            loadPosts(); // loadStats will be called after posts are loaded
            setupLocationSearch();
            
            // Add keyboard support for modals
            document.addEventListener('keydown', function(e) {
                if (e.key === 'Escape') {
                    const modal = document.getElementById('edit-modal');
                    const imageModal = document.getElementById('image-modal');
                    
                    // Prioritize image modal - close it first if it's open
                    if (imageModal && imageModal.style.display === 'block') {
                        e.preventDefault();
                        e.stopPropagation();
                        e.stopImmediatePropagation();
                        closeImageModal();
                        return;
                    }
                    
                    // Close edit modal only if image modal is not open
                    if (modal && modal.style.display === 'block') {
                        closeModal();
                    }
                }
            }, true); // Use capture phase to run before other handlers
            
            // Handle browser back/forward buttons
            window.addEventListener('popstate', function() {
                initializeFromQueryString();
            });
        });

        async function loadStats() {
            // Calculate stats from loaded posts instead of API
            if (allPosts.length === 0) return;
            
            const problematicCount = allPosts.filter(post => post.published && isProblematic(post)).length;
            const publishedCount = allPosts.filter(post => post.published && !isProblematic(post) && post.rating && post.rating > 0 && !needsPolish(post)).length;
            const unratedCount = allPosts.filter(post => post.published && !isProblematic(post) && (!post.rating || post.rating === '' || post.rating == 0)).length;
            const needsPolishCount = allPosts.filter(post => post.published && needsPolish(post)).length;
            
            document.getElementById('total-posts').textContent = allPosts.length;
            document.getElementById('published-posts').textContent = publishedCount;
            document.getElementById('unrated-posts').textContent = unratedCount;
            document.getElementById('needs-polish-posts').textContent = needsPolishCount;
            document.getElementById('problematic-posts').textContent = problematicCount;
        }

        async function loadPosts() {
            try {
                const response = await fetch(`${API_BASE}/posts`);
                allPosts = await response.json();
                renderPosts();
                loadStats(); // Update stats after posts are loaded
                document.getElementById('loading').style.display = 'none';
            } catch (error) {
                console.error('Error loading posts:', error);
                document.getElementById('loading').textContent = 'Error loading posts. Make sure the API server is running.';
            }
        }

        function renderPosts() {
            const publishedGrid = document.getElementById('published-posts-grid');
            const unratedGrid = document.getElementById('unrated-posts-grid');
            const needsPolishGrid = document.getElementById('needs-polish-posts-grid');
            const problematicGrid = document.getElementById('problematic-posts-grid');
            
            publishedGrid.innerHTML = '';
            unratedGrid.innerHTML = '';
            needsPolishGrid.innerHTML = '';
            problematicGrid.innerHTML = '';

            const problematicPosts = allPosts.filter(post => post.published && isProblematic(post));
            const publishedPosts = allPosts.filter(post => post.published && !isProblematic(post) && post.rating && post.rating > 0 && !needsPolish(post));
            const unratedPosts = allPosts.filter(post => post.published && !isProblematic(post) && (!post.rating || post.rating === '' || post.rating == 0));
            const needsPolishPosts = allPosts.filter(post => post.published && needsPolish(post));

            // Group posts by continent, country, city
            renderGroupedPosts(publishedGrid, publishedPosts);
            renderGroupedPosts(unratedGrid, unratedPosts);
            renderGroupedPosts(needsPolishGrid, needsPolishPosts);
            renderGroupedPosts(problematicGrid, problematicPosts);
        }
        
        function renderGroupedPosts(container, posts) {
            // Group posts by continent -> country -> city
            const grouped = {};
            
            posts.forEach(post => {
                const continent = getContinent(post.country) || 'Unknown';
                const country = post.country || 'Unknown';
                const city = post.city || 'Unknown';
                
                if (!grouped[continent]) grouped[continent] = {};
                if (!grouped[continent][country]) grouped[continent][country] = {};
                if (!grouped[continent][country][city]) grouped[continent][country][city] = [];
                
                grouped[continent][country][city].push(post);
            });
            
            // Sort continents, countries, and cities
            const sortedContinents = Object.keys(grouped).sort();
            
            sortedContinents.forEach(continent => {
                // Create continent section
                const continentDiv = document.createElement('div');
                continentDiv.className = 'continent-group';
                continentDiv.innerHTML = `<h3 class="continent-header">${continent}</h3>`;
                
                const sortedCountries = Object.keys(grouped[continent]).sort();
                
                sortedCountries.forEach(country => {
                    // Create country section
                    const countryDiv = document.createElement('div');
                    countryDiv.className = 'country-group';
                    countryDiv.innerHTML = `<h4 class="country-header">${country}</h4>`;
                    
                    const sortedCities = Object.keys(grouped[continent][country]).sort();
                    
                    sortedCities.forEach(city => {
                        // Create city section
                        const cityDiv = document.createElement('div');
                        cityDiv.className = 'city-group';
                        cityDiv.innerHTML = `<h5 class="city-header">üìç ${city}</h5>`;
                        
                        const cityPosts = grouped[continent][country][city];
                        const postsGrid = document.createElement('div');
                        postsGrid.className = 'posts-grid';
                        
                        // Sort posts by date (newest first)
                        cityPosts.sort((a, b) => new Date(b.date || 0) - new Date(a.date || 0));
                        
                        cityPosts.forEach(post => {
                            postsGrid.appendChild(createPostCard(post));
                        });
                        
                        cityDiv.appendChild(postsGrid);
                        countryDiv.appendChild(cityDiv);
                    });
                    
                    continentDiv.appendChild(countryDiv);
                });
                
                container.appendChild(continentDiv);
            });
        }
        
        function getContinent(country) {
            // Map countries to continents
            const continentMap = {
                'Canada': 'North America',
                'United States': 'North America',
                'Mexico': 'North America',
                'Chile': 'South America',
                'Argentina': 'South America',
                'Brazil': 'South America',
                'Peru': 'South America',
                'Colombia': 'South America',
                'United Kingdom': 'Europe',
                'Ireland': 'Europe',
                'France': 'Europe',
                'Germany': 'Europe',
                'Italy': 'Europe',
                'Spain': 'Europe',
                'Portugal': 'Europe',
                'Netherlands': 'Europe',
                'Belgium': 'Europe',
                'Switzerland': 'Europe',
                'Austria': 'Europe',
                'Sweden': 'Europe',
                'Norway': 'Europe',
                'Denmark': 'Europe',
                'Finland': 'Europe',
                'Japan': 'Asia',
                'China': 'Asia',
                'South Korea': 'Asia',
                'Thailand': 'Asia',
                'Vietnam': 'Asia',
                'Singapore': 'Asia',
                'Malaysia': 'Asia',
                'Indonesia': 'Asia',
                'Philippines': 'Asia',
                'India': 'Asia',
                'Australia': 'Oceania',
                'New Zealand': 'Oceania',
                'South Africa': 'Africa',
                'Kenya': 'Africa',
                'Ethiopia': 'Africa',
                'Morocco': 'Africa'
            };
            return continentMap[country];
        }

        function createPostCard(post) {
            const card = document.createElement('div');
            card.className = 'post-card';

            const images = post.images || [];
            const heroImage = images.length > 0 ? images[0] : null;
            const date = post.date ? new Date(post.date).toLocaleDateString() : 'No date';
            const location = [post.city, post.country].filter(x => x && x !== 'Unknown').join(', ') || 'Unknown location';
            const geoposition = (post.latitude && post.longitude) ? `${parseFloat(post.latitude).toFixed(4)}, ${parseFloat(post.longitude).toFixed(4)}` : 'No coordinates';

            card.innerHTML = `
                ${heroImage ? `
                <div class="post-hero-image">
                    <img src="${heroImage.startsWith('/') ? '.' + heroImage : heroImage}" alt="${post.cafe_name || 'Untitled'}" loading="lazy">
                    ${images.length > 1 ? `<div class="image-count">+${images.length - 1} more</div>` : ''}
                </div>
                ` : ''}
                <div class="post-content">
                    <div class="post-title">${post.cafe_name || 'Untitled Cafe'}</div>
                    <div class="post-meta">
                        ${location} ‚Ä¢ ${date} ‚Ä¢ üåç ${geoposition}${post.rating ? ` ‚Ä¢ ${'‚òï'.repeat(post.rating)}` : ''}
                    </div>
                    ${post.notes ? `<div class="post-description">${post.notes}</div>` : ''}
                </div>
                <div class="post-actions">
                    <div class="inline-rating" data-post-id="${post.id}">
                        <span class="rating-label">Rate:</span>
                        ${[1,2,3,4,5,6].map(star => `
                            <button class="rating-star ${post.rating >= star ? 'active' : ''}" 
                                    data-rating="${star}" 
                                    onclick="updatePostRating(${post.id}, ${star})"
                                    title="${star === 6 ? '5+ cups' : star + ' cup' + (star > 1 ? 's' : '')}">
                                ‚òï
                            </button>
                        `).join('')}
                        ${post.rating ? `<span class="current-rating">${post.rating === 6 ? '5+' : post.rating}</span>` : ''}
                    </div>
                    <div class="action-buttons">
                        <button class="btn btn-primary" onclick="editPost(${post.id})">Edit</button>
                        <button class="btn ${post.published ? 'btn-secondary' : 'btn-primary'}" onclick="togglePublish(${post.id}, ${post.published})">
                            ${post.published ? 'Unpublish' : 'Publish'}
                        </button>
                    </div>
                </div>
            `;

            return card;
        }

        function switchTab(tab, updateUrl = true) {
            // Update tab buttons
            document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
            const tabIndex = tab === 'published' ? 1 : tab === 'unrated' ? 2 : tab === 'needs-polish' ? 3 : 4;
            document.querySelector(`.tab:nth-child(${tabIndex})`).classList.add('active');

            // Update tab content
            document.querySelectorAll('.tab-content').forEach(t => t.classList.remove('active'));
            document.getElementById(`${tab}-content`).classList.add('active');
            
            // Update URL query string
            if (updateUrl) {
                updateQueryString('tab', tab);
            }
        }
        
        function updateQueryString(key, value) {
            const url = new URL(window.location);
            if (value && value !== 'published') { // Don't add query for default tab
                url.searchParams.set(key, value);
            } else {
                url.searchParams.delete(key);
            }
            window.history.pushState({}, '', url);
        }
        
        function getQueryParam(key, defaultValue) {
            const url = new URL(window.location);
            return url.searchParams.get(key) || defaultValue;
        }
        
        function initializeFromQueryString() {
            const tab = getQueryParam('tab', 'published');
            const validTabs = ['published', 'unrated', 'needs-polish', 'problematic'];
            
            if (validTabs.includes(tab)) {
                switchTab(tab, false); // Don't update URL when initializing
            }
        }

        async function editPost(id) {
            try {
                const response = await fetch(`${API_BASE}/posts/${id}`);
                currentPost = await response.json();
                
                document.getElementById('modal-title').textContent = 'Edit Post';
                document.getElementById('post-id').value = currentPost.id;
                document.getElementById('title').value = currentPost.title || '';
                document.getElementById('date').value = currentPost.date || '';
                document.getElementById('cafe-name').value = currentPost.cafe_name || '';
                document.getElementById('city').value = currentPost.city || '';
                document.getElementById('country').value = currentPost.country || '';
                document.getElementById('continent').value = currentPost.continent || '';
                document.getElementById('latitude').value = currentPost.latitude || '';
                document.getElementById('longitude').value = currentPost.longitude || '';
                document.getElementById('rating').value = currentPost.rating || '';
                document.getElementById('description').value = currentPost.notes || '';
                
                renderImagesList(currentPost.images || []);
                document.getElementById('edit-modal').style.display = 'block';
                
            } catch (error) {
                console.error('Error loading post:', error);
                alert('Error loading post');
            }
        }


        function closeModal() {
            document.getElementById('edit-modal').style.display = 'none';
            clearLocationSearch();
        }
        
        
        function clearLocationSearch() {
            // Clear the search input
            const searchInput = document.getElementById('location-search');
            if (searchInput) {
                searchInput.value = '';
            }
            
            // Hide suggestions and preview
            hideSuggestions();
            hideGeocodePreview();
            
            // Clear search status
            const searchStatus = document.getElementById('search-status');
            if (searchStatus) {
                searchStatus.textContent = '';
                searchStatus.className = 'search-status';
            }
            
            // Cancel any ongoing search
            if (currentSearchController) {
                currentSearchController.abort();
                currentSearchController = null;
            }
        }

        function openImageModal(imageSrc) {
            document.getElementById('modal-image').src = imageSrc;
            document.getElementById('image-modal').style.display = 'block';
        }

        function closeImageModal() {
            document.getElementById('image-modal').style.display = 'none';
            document.getElementById('modal-image').src = '';
        }

        async function togglePublish(postId, currentStatus) {
            // Don't allow publishing problematic posts
            if (!currentStatus) { // If trying to publish
                const post = allPosts.find(p => p.id === postId);
                if (post && isProblematic(post)) {
                    alert('Cannot publish post: Missing required information (cafe name, location, coordinates, or continent)');
                    return;
                }
            }

            try {
                const response = await fetch(`${API_BASE}/posts/${postId}`, {
                    method: 'PUT',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ published: !currentStatus })
                });

                if (response.ok) {
                    // Reload posts and auto-regenerate Jekyll
                    loadPosts();
                    
                    try {
                        await fetch(`${API_BASE}/regenerate`, { method: 'POST' });
                        console.log('Jekyll posts regenerated');
                    } catch (error) {
                        console.error('Error regenerating Jekyll posts:', error);
                    }
                } else {
                    alert('Error updating post status');
                }
            } catch (error) {
                console.error('Error toggling publish status:', error);
                alert('Error updating post status');
            }
        }

        async function updatePostRating(postId, rating) {
            try {
                // Get the current post data to preserve all fields
                const post = allPosts.find(p => p.id === postId);
                if (!post) {
                    console.error('Post not found:', postId);
                    return;
                }
                
                const response = await fetch(`${API_BASE}/posts/${postId}`, {
                    method: 'PUT',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ 
                        ...post, 
                        rating: rating,
                        published: post.published || false // Ensure published field is included
                    })
                });

                if (response.ok) {
                    // Update the rating in the local data
                    const post = allPosts.find(p => p.id === postId);
                    if (post) {
                        post.rating = rating;
                    }
                    
                    // Update the visual rating in the card
                    const ratingContainer = document.querySelector(`[data-post-id="${postId}"]`);
                    if (ratingContainer) {
                        // Update active states
                        ratingContainer.querySelectorAll('.rating-star').forEach((star, index) => {
                            star.classList.toggle('active', rating >= (index + 1));
                        });
                        
                        // Update current rating display
                        let currentRatingSpan = ratingContainer.querySelector('.current-rating');
                        if (!currentRatingSpan) {
                            currentRatingSpan = document.createElement('span');
                            currentRatingSpan.className = 'current-rating';
                            ratingContainer.appendChild(currentRatingSpan);
                        }
                        currentRatingSpan.textContent = rating === 6 ? '5+' : rating;
                    }
                    
                    // Update the post meta line in the card to show new rating
                    const postCard = ratingContainer.closest('.post-card');
                    const metaDiv = postCard.querySelector('.post-meta');
                    if (metaDiv && post) {
                        const location = [post.city, post.country].filter(x => x && x !== 'Unknown').join(', ') || 'Unknown location';
                        const date = post.date ? new Date(post.date).toLocaleDateString() : 'No date';
                        const geoposition = (post.latitude && post.longitude) ? `${parseFloat(post.latitude).toFixed(4)}, ${parseFloat(post.longitude).toFixed(4)}` : 'No coordinates';
                        metaDiv.innerHTML = `${location} ‚Ä¢ ${date} ‚Ä¢ üåç ${geoposition}${post.rating ? ` ‚Ä¢ ${'‚òï'.repeat(Math.min(post.rating, 5))}${post.rating === 6 ? '+' : ''}` : ''}`;
                    }
                    
                    // Re-render posts to move between sections and update stats
                    renderPosts();
                    loadStats();
                    
                    console.log(`Updated rating for post ${postId} to ${rating}`);
                } else {
                    alert('Error updating post rating');
                }
            } catch (error) {
                console.error('Error updating post rating:', error);
                alert('Error updating post rating');
            }
        }

        function renderImagesList(images) {
            const container = document.getElementById('images-list');
            container.innerHTML = '';
            
            // Add existing images as tiles with drag-and-drop
            images.forEach((image, index) => {
                const tile = document.createElement('div');
                tile.className = 'image-tile';
                tile.draggable = images.length > 1; // Only draggable if multiple images
                tile.dataset.index = index;
                
                // Add drag handle (only show if there are multiple images)
                tile.innerHTML = `
                    ${images.length > 1 ? `<div class="drag-handle" title="Drag to reorder">‚ãÆ‚ãÆ</div>` : ''}
                    <div class="image-position-indicator">${index + 1}</div>
                    <img src="${image.startsWith('/') ? '.' + image : image}" onerror="this.style.display='none'" alt="Image ${index + 1}" onclick="openImageModal('${image.startsWith('/') ? '.' + image : image}')">
                    <div class="image-tile-controls">
                        <input type="text" value="${image}" onchange="updateImage(${index}, this.value)" placeholder="Image URL">
                        <button type="button" class="remove-btn" onclick="removeImage(${index})">Remove</button>
                    </div>
                `;
                
                // Add drag event listeners
                tile.addEventListener('dragstart', handleDragStart);
                tile.addEventListener('dragover', handleDragOver);
                tile.addEventListener('drop', handleDrop);
                tile.addEventListener('dragend', handleDragEnd);
                tile.addEventListener('dragenter', handleDragEnter);
                tile.addEventListener('dragleave', handleDragLeave);
                
                container.appendChild(tile);
            });
            
            // Add "Add Image" button
            const addBtn = document.createElement('div');
            addBtn.className = 'add-image-btn';
            addBtn.innerHTML = '+ Add Image';
            addBtn.onclick = addImageField;
            container.appendChild(addBtn);
        }

        // Drag and drop functionality
        let draggedElement = null;
        let draggedIndex = null;

        function handleDragStart(e) {
            draggedElement = this;
            draggedIndex = parseInt(this.dataset.index);
            this.classList.add('dragging');
            e.dataTransfer.effectAllowed = 'move';
            e.dataTransfer.setData('text/html', this.outerHTML);
        }

        function handleDragOver(e) {
            if (e.preventDefault) {
                e.preventDefault();
            }
            e.dataTransfer.dropEffect = 'move';
            return false;
        }

        function handleDragEnter(e) {
            this.classList.add('drag-over');
        }

        function handleDragLeave(e) {
            this.classList.remove('drag-over');
        }

        function handleDrop(e) {
            if (e.stopPropagation) {
                e.stopPropagation();
            }

            if (draggedElement !== this) {
                const dropIndex = parseInt(this.dataset.index);
                const images = getCurrentImages();
                
                // Move the image in the array
                const draggedImage = images[draggedIndex];
                images.splice(draggedIndex, 1);
                images.splice(dropIndex, 0, draggedImage);
                
                // Re-render the images list
                renderImagesList(images);
            }

            return false;
        }

        function handleDragEnd(e) {
            // Clean up
            document.querySelectorAll('.image-tile').forEach(tile => {
                tile.classList.remove('dragging', 'drag-over');
            });
            draggedElement = null;
            draggedIndex = null;
        }

        function addImageField() {
            const images = getCurrentImages();
            images.push('');
            renderImagesList(images);
        }

        function updateImage(index, value) {
            const images = getCurrentImages();
            images[index] = value;
            renderImagesList(images);
        }

        function removeImage(index) {
            const images = getCurrentImages();
            images.splice(index, 1);
            renderImagesList(images);
        }

        function getCurrentImages() {
            const inputs = document.querySelectorAll('#images-list input[type="text"]');
            return Array.from(inputs).map(input => input.value).filter(value => value.trim());
        }

        document.getElementById('post-form').addEventListener('submit', async function(e) {
            e.preventDefault();
            
            const formData = {
                title: document.getElementById('title').value,
                date: document.getElementById('date').value,
                cafe_name: document.getElementById('cafe-name').value,
                city: document.getElementById('city').value,
                country: document.getElementById('country').value,
                continent: document.getElementById('continent').value,
                latitude: parseFloat(document.getElementById('latitude').value) || null,
                longitude: parseFloat(document.getElementById('longitude').value) || null,
                rating: parseInt(document.getElementById('rating').value) || null,
                notes: document.getElementById('description').value,
                published: currentPost ? currentPost.published : false, // Keep current publish status when editing
                images: getCurrentImages()
            };

            // Prevent publishing problematic posts
            if (formData.published && isProblematic(formData)) {
                alert('Cannot publish post: Missing required information (cafe name, location, coordinates, or continent)');
                return;
            }

            try {
                let response;
                if (currentPost) {
                    // Update existing post
                    response = await fetch(`${API_BASE}/posts/${currentPost.id}/update`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(formData)
                    });
                } else {
                    // Create new post
                    response = await fetch(`${API_BASE}/posts`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(formData)
                    });
                }

                if (response.ok) {
                    const result = await response.json();
                    console.log('Save successful:', result);
                    closeModal();
                    loadPosts(); // This will also refresh stats
                    
                    // Automatically regenerate Jekyll posts after editing
                    try {
                        await fetch(`${API_BASE}/regenerate`, { method: 'POST' });
                        // Silent success - user knows regeneration happens automatically
                    } catch (error) {
                        console.error('Error regenerating Jekyll posts:', error);
                        alert(currentPost ? 'Post updated successfully, but Jekyll regeneration failed' : 'Post created successfully, but Jekyll regeneration failed');
                    }
                } else {
                    const errorText = await response.text();
                    console.error('Save error:', response.status, response.statusText, errorText);
                    alert('Error saving post: ' + (errorText || response.statusText));
                }
            } catch (error) {
                console.error('Error saving post:', error);
                alert('Error saving post');
            }
        });

        async function deletePost() {
            if (!currentPost || !confirm('Are you sure you want to delete this post?')) {
                return;
            }

            try {
                const response = await fetch(`${API_BASE}/posts/${currentPost.id}/delete`, {
                    method: 'POST'
                });

                if (response.ok) {
                    closeModal();
                    loadPosts(); // This will also refresh stats
                    
                    // Automatically regenerate Jekyll posts after deletion
                    try {
                        await fetch(`${API_BASE}/regenerate`, { method: 'POST' });
                        // Silent success - user knows regeneration happens automatically
                    } catch (error) {
                        console.error('Error regenerating Jekyll posts:', error);
                        alert('Post deleted successfully, but Jekyll regeneration failed');
                    }
                } else {
                    alert('Error deleting post');
                }
            } catch (error) {
                console.error('Error deleting post:', error);
                alert('Error deleting post');
            }
        }

        async function regeneratePosts() {
            if (!confirm('This will regenerate all Jekyll post files from the database. Continue?')) {
                return;
            }

            try {
                const response = await fetch(`${API_BASE}/regenerate`, {
                    method: 'POST'
                });

                if (response.ok) {
                    console.log('Post regeneration started successfully');
                } else {
                    alert('Error starting regeneration');
                }
            } catch (error) {
                console.error('Error regenerating posts:', error);
                alert('Error regenerating posts');
            }
        }

        // Search functionality
        document.getElementById('search').addEventListener('input', function(e) {
            const query = e.target.value.toLowerCase();
            const cards = document.querySelectorAll('.post-card');
            
            cards.forEach(card => {
                const text = card.textContent.toLowerCase();
                card.style.display = text.includes(query) ? 'grid' : 'none';
            });
        });
    </script>
    
    <script>
    // Mobile menu functionality
    document.addEventListener('DOMContentLoaded', function() {
        const burgerMenu = document.getElementById('burger-menu');
        const mobileNav = document.getElementById('mobile-nav');
        const closeMobileNav = document.getElementById('close-mobile-nav');
        const body = document.body;
        
        let scrollPosition = 0;
        
        if (burgerMenu && mobileNav) {
            burgerMenu.addEventListener('click', function() {
                scrollPosition = window.pageYOffset;
                mobileNav.classList.add('open');
                body.classList.add('mobile-scroll-disabled');
                body.style.top = `-${scrollPosition}px`;
            });
            
            if (closeMobileNav) {
                closeMobileNav.addEventListener('click', function() {
                    mobileNav.classList.remove('open');
                    body.classList.remove('mobile-scroll-disabled');
                    body.style.top = '';
                    window.scrollTo(0, scrollPosition);
                });
            }
            
            // Close menu when clicking outside
            document.addEventListener('click', function(e) {
                if (!mobileNav.contains(e.target) && !burgerMenu.contains(e.target) && mobileNav.classList.contains('open')) {
                    mobileNav.classList.remove('open');
                    body.classList.remove('mobile-scroll-disabled');
                    body.style.top = '';
                    window.scrollTo(0, scrollPosition);
                }
            });
            
            // Close menu when clicking a nav link
            mobileNav.querySelectorAll('a').forEach(link => {
                link.addEventListener('click', function() {
                    mobileNav.classList.remove('open');
                    body.classList.remove('mobile-scroll-disabled');
                });
            });
        }
    });
    </script>
</body>
</html>