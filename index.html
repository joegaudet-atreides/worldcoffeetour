---
layout: default
title: World Coffee Tour
---


{% comment %} Split posts into published and unpublished - moved up for latest post {% endcomment %}
{% assign published_posts = site.coffee_posts | where_exp: "post", "post.published != false" %}

<div id="map" class="main-map"></div>

{% comment %} Get the latest published post {% endcomment %}
{% assign latest_post = published_posts | sort: 'date' | last %}

{% if latest_post %}
<div class="latest-stop-section">
    <div class="latest-stop-container">
        <div class="latest-stop-header">
            <h2>Latest Stop</h2>
            <span class="latest-stop-date">{{ latest_post.date | date: "%B %d, %Y" }}</span>
        </div>
        
        <a href="{{ latest_post.url | relative_url }}" class="latest-stop-card">
            {% if latest_post.images and latest_post.images.size > 0 %}
            <div class="latest-stop-image">
                <img src="{{ latest_post.images[0] | relative_url }}" alt="{{ latest_post.title }}" loading="lazy">
            </div>
            {% elsif latest_post.image_url %}
            <div class="latest-stop-image">
                <img src="{{ latest_post.image_url }}" alt="{{ latest_post.title }}" loading="lazy">
            </div>
            {% endif %}
            
            <div class="latest-stop-content">
                <h3 class="latest-stop-title">
                    {% if latest_post.cafe_name %}{{ latest_post.cafe_name }}{% else %}{{ latest_post.title }}{% endif %}
                </h3>
                
                <div class="latest-stop-location">
                    <span class="location-icon">üìç</span>
                    {{ latest_post.city }}, {{ latest_post.country }}
                </div>
                
                {% if latest_post.rating %}
                <div class="latest-stop-rating">
                    {% for i in (1..5) %}
                        {% if i <= latest_post.rating %}‚òï{% endif %}
                    {% endfor %}
                    {% if latest_post.rating > 5 %}+{% endif %}
                </div>
                {% endif %}
                
                {% if latest_post.notes %}
                <p class="latest-stop-description">{{ latest_post.notes | truncatewords: 30 }}</p>
                {% endif %}
                
                <span class="latest-stop-cta">View Full Post ‚Üí</span>
            </div>
        </a>
    </div>
</div>
{% endif %}

<div class="filter-controls">
    <button class="filter-btn active" data-continent="all">All Continents</button>
    <button class="filter-btn" data-continent="north-america">North America</button>
    <button class="filter-btn" data-continent="south-america">South America</button>
    <button class="filter-btn" data-continent="europe">Europe</button>
    <button class="filter-btn" data-continent="asia">Asia</button>
    <button class="filter-btn" data-continent="africa">Africa</button>
    <button class="filter-btn" data-continent="oceania">Oceania</button>
</div>
{% assign unpublished_posts = site.coffee_posts | where: 'published', false %}
{% comment %} Group by continent and move Unknown/empty to end {% endcomment %}
{% assign posts_by_continent_raw = published_posts | group_by: 'continent' | sort: 'name' %}
{% assign all_continents = posts_by_continent_raw %}
{% assign posts_by_continent = "" | split: "" %}
{% for continent in all_continents %}
  {% if continent.name != 'Unknown' and continent.name != '' %}
    {% assign posts_by_continent = posts_by_continent | push: continent %}
  {% endif %}
{% endfor %}
{% for continent in all_continents %}
  {% if continent.name == 'Unknown' or continent.name == '' %}
    {% assign posts_by_continent = posts_by_continent | push: continent %}
  {% endif %}
{% endfor %}

<div class="content-wrapper">
    <div class="posts-content">
            {% for continent in posts_by_continent %}
            <section class="continent-section" id="{{ continent.name | downcase | replace: ' ', '-' }}" data-continent="{{ continent.name | downcase | replace: ' ', '-' }}">
                <h1 class="continent-title">
                    <a href="#{{ continent.name | downcase | replace: ' ', '-' }}" class="section-link">{% if continent.name == '' %}Unknown{% else %}{{ continent.name }}{% endif %}</a>
                </h1>
        
        {% assign posts_by_country = continent.items | group_by: 'country' | sort: 'name' %}
        
        {% for country in posts_by_country %}
        <div class="country-section" id="{{ continent.name | downcase | replace: ' ', '-' }}-{{ country.name | downcase | replace: ' ', '-' }}" data-country="{{ country.name }}" data-continent="{{ continent.name }}">
            <h2 class="country-title">
                <a href="#{{ continent.name | downcase | replace: ' ', '-' }}-{{ country.name | downcase | replace: ' ', '-' }}" class="section-link">{{ country.name }}</a>
            </h2>
            
            {% assign posts_by_city = country.items | group_by: 'city' | sort: 'name' %}
            
            {% for city in posts_by_city %}
            <div class="city-section" id="{{ continent.name | downcase | replace: ' ', '-' }}-{{ country.name | downcase | replace: ' ', '-' }}-{{ city.name | downcase | replace: ' ', '-' }}" data-city="{{ city.name }}" data-country="{{ country.name }}" data-continent="{{ continent.name }}">
                <h3 class="city-title">üìç {{ city.name }}</h3>
                
                <div class="coffee-grid">
                    {% assign sorted_posts = city.items | sort: 'date' | reverse %}
                    {% for post in sorted_posts %}
                    <a href="{{ post.url | relative_url }}" class="coffee-card" data-lat="{{ post.latitude }}" data-lng="{{ post.longitude }}">
                        {% if post.images and post.images.size > 0 %}
                        <img src="{{ post.images[0] | relative_url }}" alt="{{ post.title }}" class="coffee-card-image" loading="lazy">
                        {% elsif post.image_url %}
                        <img src="{{ post.image_url }}" alt="{{ post.title }}" class="coffee-card-image" loading="lazy">
                        {% else %}
                        <div class="coffee-card-image" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); display: flex; align-items: center; justify-content: center; font-size: 3rem;">‚òï</div>
                        {% endif %}
                        <div class="coffee-card-content">
                            {% if post.cafe_name %}
                            <h3 class="coffee-card-title">{{ post.cafe_name }}</h3>
                            {% if post.notes %}
                            <p class="coffee-card-description">{{ post.notes | truncatewords: 20 }}</p>
                            {% endif %}
                            {% else %}
                            <h3 class="coffee-card-title">{{ post.title }}</h3>
                            {% if post.notes %}
                            <p class="coffee-card-description">{{ post.notes | truncatewords: 20 }}</p>
                            {% endif %}
                            {% endif %}
                            <div class="coffee-card-meta">
                                <div class="coffee-card-details">
                                    <span class="coffee-card-date">{{ post.date | date: "%b %Y" }}</span>
                                    <span class="coffee-card-location">{{ post.city }}, {{ post.country }}</span>
                                    {% if post.rating %}
                                    <span class="coffee-card-rating">
                                        {% for i in (1..5) %}
                                            {% if i <= post.rating %}‚òï{% endif %}
                                        {% endfor %}
                                        {% if post.rating > 5 %}+{% endif %}
                                    </span>
                                    {% endif %}
                                </div>
                            </div>
                        </div>
                    </a>
                    {% endfor %}
                </div>
            </div>
            {% endfor %}
            
        </div>
        {% endfor %}
            
            </section>
            {% endfor %}

            <!-- Empty sections for future continents -->
            <section class="continent-section" id="oceania" data-continent="oceania">
                <h1 class="continent-title">
                    <a href="#oceania" class="section-link">Oceania</a>
                </h1>
                <div class="coming-soon">
                    <div class="coming-soon-content">
                        <span class="coming-soon-emoji">‚úàÔ∏è</span>
                        <h2>Coming Soon</h2>
                        <p>Coffee adventures awaiting in the Pacific!</p>
                    </div>
                </div>
            </section>

            <section class="continent-section" id="africa" data-continent="africa">
                <h1 class="continent-title">
                    <a href="#africa" class="section-link">Africa</a>
                </h1>
                <div class="coming-soon">
                    <div class="coming-soon-content">
                        <span class="coming-soon-emoji">‚úàÔ∏è</span>
                        <h2>Coming Soon</h2>
                        <p>Exploring the birthplace of coffee!</p>
                    </div>
                </div>
            </section>
    </div>
</div>


<!-- If no posts yet, show placeholder -->
{% if site.coffee_posts.size == 0 %}
<div class="no-posts">
    <h2>Coffee adventures coming soon...</h2>
    <p>Posts tagged with #worldcoffeetour will appear here</p>
</div>
{% endif %}

<script>
// Pass coffee posts data to JavaScript
const coffeePostsData = [
    {% for post in published_posts %}
    {
        title: "{{ post.title | escape }}",
        url: "{{ post.url | relative_url }}",
        city: "{{ post.city | escape }}",
        country: "{{ post.country | escape }}",
        continent: "{{ post.continent | escape }}",
        latitude: {{ post.latitude | default: 'null' }},
        longitude: {{ post.longitude | default: 'null' }}
    }{% unless forloop.last %},{% endunless %}
    {% endfor %}
];

// Map functionality
let mainMap;
let isSticky = false;
let currentHoveredCard = null;
let mapContainer = null;
let animationId = null;
let mapOriginalRect = null;
let scrollThreshold = 0;
let scrollEventCount = 0;

// Mobile detection
function isMobileDevice() {
    return window.innerWidth <= 768 || /Android|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
}

document.addEventListener('DOMContentLoaded', function() {
    // Wait for main.js to initialize the map
    const initMainMap = () => {
        if (window.mainMap) {
            mainMap = window.mainMap;
            console.log('mainMap connected:', !!mainMap);
            // Filter buttons are already set up below - no need for setupFilterButtons
        } else {
            setTimeout(initMainMap, 50);
        }
    };
    initMainMap();
    
    const filterBtns = document.querySelectorAll('.filter-btn');
    const continentSections = document.querySelectorAll('.continent-section');
    const countrySections = document.querySelectorAll('.country-section');
    const contentWrapper = document.querySelector('.content-wrapper');
    
    // Get the main map element
    mapContainer = document.getElementById('map');
    
    // Calculate scroll threshold
    function updateScrollThreshold() {
        if (!mapContainer) {
            console.log('updateScrollThreshold early return:', { mapContainer: !!mapContainer });
            return;
        }
        
        const mapRect = mapContainer.getBoundingClientRect();
        
        // First calculate the map's original position
        mapOriginalRect = {
            top: mapRect.top + window.scrollY,
            left: mapRect.left,
            width: mapRect.width,
            height: mapRect.height
        };
        
        // Scroll threshold should be when the map intersects with the site header
        // Get the header height to know when the map hits the toolbar
        const siteHeader = document.querySelector('.site-header');
        const headerHeight = siteHeader ? siteHeader.offsetHeight : 0;
        const targetPadding = 60; // The top padding we want for the sticky map
        
        // Animation starts when the map would reach its final sticky position
        // This prevents the map from ever going under the toolbar
        scrollThreshold = mapOriginalRect.top - headerHeight - targetPadding;
        
        console.log('updateScrollThreshold:', { scrollThreshold, mapOriginalRect });
    }
    
    updateScrollThreshold();
    
    // Initialize state based on current scroll position (for page refresh)
    setTimeout(() => {
        if (isMobileDevice()) {
            updateMobileMapView();
        } else {
            updateMapAnimation();
        }
    }, 100);
    
    // Listen for scroll events
    let ticking = false;
    window.addEventListener('scroll', () => {
        scrollEventCount++;
        // if (scrollEventCount % 10 === 0) { // Log every 10th scroll event to avoid spam
        //     console.log('Scroll event #', scrollEventCount, 'scrollY:', window.scrollY);
        // }
        
        if (!ticking) {
            requestAnimationFrame(() => {
                const isMobile = isMobileDevice();
                if (isMobile) {
                    // On mobile, map stays as hero - no sticky animation, but still zoom to visible sections
                    updateMobileMapView();
                } else {
                    updateMapAnimation();
                }
                updateBreadcrumb();
                ticking = false;
            });
            ticking = true;
        }
    });
    
    // Update on resize
    window.addEventListener('resize', () => {
        updateScrollThreshold();
        if (isMobileDevice()) {
            // On mobile, update map view without animation
            updateMobileMapView();
        } else {
            updateMapAnimation();
        }
    });
    
    // Add touch event support for mobile scroll detection
    if (isMobileDevice()) {
        let touchStartY = 0;
        document.addEventListener('touchstart', (e) => {
            touchStartY = e.touches[0].clientY;
        }, { passive: true });
        
        document.addEventListener('touchmove', (e) => {
            // This ensures scroll events are triggered on touch devices
            // The scroll event listener above will handle the actual map updates
        }, { passive: true });
        
        document.addEventListener('touchend', () => {
            // Force an update after touch ends to ensure we're in sync
            setTimeout(() => {
                updateMobileMapView();
            }, 100);
        }, { passive: true });
    }
    
    // Initialize intersection observer for auto-zooming to regions, countries, and cities
    const sectionObserver = new IntersectionObserver(
        (entries) => {
            entries.forEach(entry => {
                // On mobile, map is always visible. On desktop, only when sticky
                const shouldZoom = isMobileDevice() || isSticky;
                if (entry.isIntersecting && entry.intersectionRatio > 0.3 && shouldZoom && mainMap) {
                    console.log('Section entering view:', entry.target.className, 'Should zoom:', shouldZoom, 'Is sticky:', isSticky);
                    zoomToVisibleSection(entry.target);
                }
            });
        },
        { threshold: [0.3], rootMargin: '-50px 0px -40% 0px' }
    );
    
    // Observe continent, country, and city sections for auto-zooming
    continentSections.forEach(section => {
        sectionObserver.observe(section);
    });
    
    countrySections.forEach(section => {
        sectionObserver.observe(section);
    });
    
    // Also observe city sections
    const citySections = document.querySelectorAll('.city-section');
    citySections.forEach(section => {
        sectionObserver.observe(section);
    });
    
    // Card hover functionality - zoom to individual cafe
    document.addEventListener('mouseover', function(e) {
        const card = e.target.closest('.coffee-card');
        // Only zoom if map is visible and sticky on desktop (not on mobile)
        if (card && mainMap && isSticky && !isMobileDevice()) {
            const latitude = parseFloat(card.dataset.lat);
            const longitude = parseFloat(card.dataset.lng);
            if (latitude && longitude) {
                currentHoveredCard = { lat: latitude, lng: longitude };
                console.log('Hovering card, zooming to:', latitude, longitude);
                
                // Ensure map size is correct before zooming (important during animation)
                mainMap.invalidateSize();
                
                // Small delay to ensure size is updated
                setTimeout(() => {
                    mainMap.setView([latitude, longitude], 16, {animate: true, duration: 0.5, easeLinearity: 0.25});
                }, 50);
            }
        }
    });
    
    document.addEventListener('mouseout', function(e) {
        const card = e.target.closest('.coffee-card');
        if (card && currentHoveredCard) {
            currentHoveredCard = null;
            // Return to appropriate section view after a delay
            setTimeout(() => {
                if (!currentHoveredCard && mainMap && (isSticky || isMobileDevice())) {
                    const visibleSection = getMostVisibleSection();
                    if (visibleSection) {
                        if (visibleSection.classList.contains('city-section')) {
                            const cityTitle = visibleSection.querySelector('.city-title');
                            if (cityTitle) {
                                const cityName = cityTitle.textContent.replace('üìç ', '').trim();
                                zoomToCity(cityName);
                            }
                        } else if (visibleSection.classList.contains('country-section')) {
                            zoomToCountry(visibleSection.dataset.country);
                        } else if (visibleSection.classList.contains('continent-section')) {
                            zoomToRegion(visibleSection.dataset.continent);
                        }
                    }
                }
            }, 800);
        }
    });
    
    // Filter functionality using query string approach for better reliability
    function applyFilter(continent) {
        console.log('Applying filter:', continent, 'on', isMobileDevice() ? 'mobile' : 'desktop');
        
        // Update active button
        filterBtns.forEach(b => b.classList.remove('active'));
        const activeBtn = document.querySelector(`[data-continent="${continent}"]`);
        if (activeBtn) activeBtn.classList.add('active');
        
        // Show/hide continents
        continentSections.forEach(section => {
            if (continent === 'all') {
                section.style.display = 'block';
            } else {
                const sectionContinent = section.dataset.continent;
                section.style.display = sectionContinent === continent ? 'block' : 'none';
            }
        });
        
        // Update URL without page reload
        const url = new URL(window.location);
        if (continent === 'all') {
            url.searchParams.delete('filter');
        } else {
            url.searchParams.set('filter', continent);
        }
        window.history.replaceState({}, '', url);
        
        // Zoom map to filtered area after a short delay
        setTimeout(() => {
            if (continent === 'all') {
                // Show all pins
                zoomToAllPins();
            } else {
                // Zoom to specific continent
                zoomToRegion(continent);
            }
        }, 100);
    }
    
    // Check URL for initial filter state
    function initializeFromURL() {
        const urlParams = new URLSearchParams(window.location.search);
        const filterParam = urlParams.get('filter');
        if (filterParam && filterParam !== 'all') {
            applyFilter(filterParam);
        } else {
            applyFilter('all');
        }
    }
    
    // Add event listeners to filter buttons
    filterBtns.forEach(btn => {
        const continent = btn.dataset.continent;
        
        // Handle both click and touch with unified approach
        btn.addEventListener('click', function(e) {
            e.preventDefault();
            applyFilter(continent);
        });
        
        // Touch feedback for mobile
        btn.addEventListener('touchstart', function(e) {
            this.style.transform = 'scale(0.98)';
        }, { passive: true });
        
        btn.addEventListener('touchend', function(e) {
            this.style.transform = '';
        }, { passive: true });
        
        btn.addEventListener('touchcancel', function(e) {
            this.style.transform = '';
        }, { passive: true });
    });
    
    // Initialize filter state from URL
    initializeFromURL();
    
});

let lastMobileUpdate = 0;
function updateMobileMapView() {
    // On mobile with map fixed at bottom, still update map to zoom to the visible section
    // Content scrolls underneath the fixed map
    if (!mainMap) {
        console.log('updateMobileMapView: no mainMap available');
        return;
    }
    
    // Throttle mobile updates to avoid performance issues
    const now = Date.now();
    if (now - lastMobileUpdate < 100) return; // Throttle to 10fps max for fixed map
    lastMobileUpdate = now;
    
    // Get the most visible section (accounting for fixed map at bottom)
    const visibleSection = getMostVisibleSection();
    console.log('Mobile map update: visible section:', visibleSection ? visibleSection.dataset : 'none');
    if (visibleSection) {
        zoomToVisibleSection(visibleSection);
    }
}

function updateMapAnimation() {
    if (!mapContainer || !mapOriginalRect) {
        console.log('updateMapAnimation early return:', { mapContainer: !!mapContainer, mapOriginalRect: !!mapOriginalRect });
        return;
    }
    
    const scrollY = window.scrollY;
    const viewportWidth = window.innerWidth;
    const viewportHeight = window.innerHeight;
    
    // Calculate progress (0 = hero position, 1 = sidebar position)
    const progress = Math.max(0, Math.min(1, (scrollY - scrollThreshold) / (viewportHeight * 0.3)));
    
    // console.log('updateMapAnimation:', { scrollY, scrollThreshold, progress, isSticky });
    
    // Target dimensions and position
    const targetWidth = Math.min(viewportWidth * 0.35 - 32, 600);
    const targetHeight = targetWidth * (9 / 16); // 16:9 aspect ratio
    const siteHeader = document.querySelector('.site-header');
    const headerHeight = siteHeader ? siteHeader.offsetHeight : 0;
    const targetTop = headerHeight + 35; // More top margin for better visual balance
    const targetLeft = viewportWidth - targetWidth - 32;
    
    if (progress > 0.2) {  // Only start animation when there's meaningful scroll
        // Animate to sidebar
        if (!isSticky) {
            isSticky = true;
            mapContainer.classList.add('animating');
            // Content wrapper becomes sidebar width
            const contentWrapper = document.querySelector('.content-wrapper');
            if (contentWrapper) contentWrapper.classList.add('with-sidebar');
            
            // Create placeholder
            if (!document.getElementById('map-placeholder')) {
                const placeholder = document.createElement('div');
                placeholder.id = 'map-placeholder';
                placeholder.style.height = '500px';
                placeholder.style.marginBottom = '3rem';
                placeholder.style.visibility = 'hidden';
                mapContainer.parentNode.insertBefore(placeholder, mapContainer);
            }
            
            if (mainMap) {
                // Invalidate size after the animation starts
                setTimeout(() => {
                    mainMap.invalidateSize();
                }, 300);
                
                // Wait for animation to settle before zooming
                setTimeout(() => {
                    // Only zoom to current section if this isn't the initial page load
                    if (scrollEventCount > 0) {
                        const visibleSection = getMostVisibleSection();
                        if (visibleSection) {
                            zoomToVisibleSection(visibleSection);
                        }
                    }
                }, 600);
            }
        }
        
        // Calculate the natural scroll position of the map (where it would be if not sticky)
        const naturalTop = mapOriginalRect.top - scrollY;
        
        // Ensure the map never goes above its target position (under the toolbar)
        const safeNaturalTop = Math.max(naturalTop, targetTop);
        
        // Interpolate between the safe natural position and the target sticky position
        const currentTop = safeNaturalTop + (targetTop - safeNaturalTop) * progress;
        // Don't interpolate from mapOriginalRect.left since it may not be 0 due to centering
        // Start from 30px and animate to targetLeft
        const currentLeft = 30 + (targetLeft - 30) * Math.max(0, (progress - 0.2) / 0.8);
        const currentWidth = mapOriginalRect.width + (targetWidth - mapOriginalRect.width) * progress;
        const currentHeight = mapOriginalRect.height + (targetHeight - mapOriginalRect.height) * progress;
        
        // Apply transform based on scroll progress
        mapContainer.style.top = `${currentTop}px`;
        mapContainer.style.left = `${currentLeft}px`;
        mapContainer.style.width = `${currentWidth}px`;
        mapContainer.style.height = `${currentHeight}px`;
        mapContainer.style.borderRadius = `${12 * (1 - progress * 0.5)}px`;
        
        // Invalidate map size during animation for proper rendering
        if (mainMap && progress > 0.2 && progress < 0.95) {
            // Throttle invalidateSize calls
            if (!mapContainer.invalidateSizeTimeout) {
                mapContainer.invalidateSizeTimeout = setTimeout(() => {
                    mainMap.invalidateSize();
                    mapContainer.invalidateSizeTimeout = null;
                }, 50);
            }
        }
        
        // Update box shadow
        const shadowIntensity = 0.4 + (progress * 0.2);
        mapContainer.style.boxShadow = `0 ${2 + progress * 14}px ${8 + progress * 8}px rgba(0,0,0,${shadowIntensity})`;
        
    } else {
        // Ensure map is in its natural position
        if (mapContainer.style.left || mapContainer.style.top) {
            mapContainer.style.top = '';
            mapContainer.style.left = '';
            mapContainer.style.width = '';
            mapContainer.style.height = '';
            mapContainer.style.borderRadius = '';
            mapContainer.style.boxShadow = '';
        }
        
        // Animate back to hero
        if (isSticky) {
            isSticky = false;
            mapContainer.classList.remove('animating');
            // Content wrapper returns to full width
            const contentWrapper = document.querySelector('.content-wrapper');
            if (contentWrapper) contentWrapper.classList.remove('with-sidebar');
            
            // Remove placeholder
            const placeholder = document.getElementById('map-placeholder');
            if (placeholder) {
                placeholder.remove();
            }
            
            if (mainMap) {
                setTimeout(() => {
                    mainMap.invalidateSize();
                    mainMap.setView([20, 0], 2, {animate: true, duration: 0.5});
                }, 100);
            }
        }
    }
}

// Mobile map animation removed - map stays as hero on mobile

function updateBreadcrumb() {
    const visibleSection = getMostVisibleSection();
    const titleContent = document.querySelector('.title-content');
    let breadcrumbNav = document.getElementById('breadcrumb-nav');
    
    if (!titleContent) return;
    
    // Clear breadcrumbs if at the very top of the page
    if (window.scrollY < 100) {
        if (breadcrumbNav) {
            breadcrumbNav.remove();
        }
        titleContent.classList.add('no-breadcrumb');
        return;
    }
    
    if (!visibleSection) return;
    
    const continent = visibleSection.dataset.continent;
    const country = visibleSection.dataset.country;
    const city = visibleSection.dataset.city;
    
    if (continent || country || city) {
        // Create breadcrumb if it doesn't exist
        if (!breadcrumbNav) {
            breadcrumbNav = document.createElement('div');
            breadcrumbNav.id = 'breadcrumb-nav';
            breadcrumbNav.className = 'breadcrumb-nav';
            breadcrumbNav.innerHTML = `
                <a id="breadcrumb-continent" href="#" class="breadcrumb-link"></a>
                <span id="breadcrumb-separator1" class="breadcrumb-separator"> ‚Ä∫ </span>
                <a id="breadcrumb-country" href="#" class="breadcrumb-link"></a>
                <span id="breadcrumb-separator2" class="breadcrumb-separator"> ‚Ä∫ </span>
                <a id="breadcrumb-city" href="#" class="breadcrumb-link"></a>
            `;
            titleContent.appendChild(breadcrumbNav);
        }
        
        // Show breadcrumb with animation
        breadcrumbNav.classList.add('visible');
        titleContent.classList.remove('no-breadcrumb');
        
        // Get the elements
        const continentLink = document.getElementById('breadcrumb-continent');
        const countryLink = document.getElementById('breadcrumb-country');
        const cityLink = document.getElementById('breadcrumb-city');
        const sep1 = document.getElementById('breadcrumb-separator1');
        const sep2 = document.getElementById('breadcrumb-separator2');
        
        // Clear all elements first
        continentLink.textContent = '';
        countryLink.textContent = '';
        cityLink.textContent = '';
        sep1.style.display = 'none';
        sep2.style.display = 'none';
        
        // Update continent
        if (continent) {
            const continentId = continent.toLowerCase().replace(/\s+/g, '-');
            const continentDisplay = continent.replace('-', ' ').replace(/\b\w/g, l => l.toUpperCase());
            continentLink.textContent = continentDisplay;
            continentLink.href = `#${continentId}`;
            continentLink.onclick = (e) => {
                e.preventDefault();
                const element = document.getElementById(continentId);
                console.log('Continent click:', continentId, 'element found:', !!element);
                if (element) {
                    const headerHeight = document.querySelector('.site-header').offsetHeight;
                    const isMobile = window.innerWidth <= 768;
                    const mapOffset = 0; // No mobile map offset needed since map is at bottom
                    const elementPosition = element.offsetTop - headerHeight - mapOffset - 20; // 20px extra padding
                    window.scrollTo({ top: elementPosition, behavior: 'smooth' });
                    history.pushState(null, null, `#${continentId}`);
                } else {
                    console.warn('Element not found for continent:', continentId);
                }
            };
        }
        
        // Update country
        if (country && continent) {
            const countryId = `${continent.toLowerCase().replace(/\s+/g, '-')}-${country.toLowerCase().replace(/\s+/g, '-')}`;
            countryLink.textContent = country;
            countryLink.href = `#${countryId}`;
            countryLink.onclick = (e) => {
                e.preventDefault();
                const element = document.getElementById(countryId);
                console.log('Country click:', countryId, 'element found:', !!element);
                if (element) {
                    const headerHeight = document.querySelector('.site-header').offsetHeight;
                    const isMobile = window.innerWidth <= 768;
                    const mapOffset = 0; // No mobile map offset needed since map is at bottom
                    const elementPosition = element.offsetTop - headerHeight - mapOffset - 20; // 20px extra padding
                    window.scrollTo({ top: elementPosition, behavior: 'smooth' });
                    history.pushState(null, null, `#${countryId}`);
                } else {
                    console.warn('Element not found for country:', countryId);
                }
            };
            sep1.style.display = 'inline';
        }
        
        // Update city  
        if (city && country && continent) {
            const cityId = `${continent.toLowerCase().replace(/\s+/g, '-')}-${country.toLowerCase().replace(/\s+/g, '-')}-${city.toLowerCase().replace(/\s+/g, '-')}`;
            cityLink.textContent = city;
            cityLink.href = `#${cityId}`;
            cityLink.onclick = (e) => {
                e.preventDefault();
                const element = document.getElementById(cityId);
                console.log('City click:', cityId, 'element found:', !!element);
                if (element) {
                    const headerHeight = document.querySelector('.site-header').offsetHeight;
                    const isMobile = window.innerWidth <= 768;
                    const mapOffset = 0; // No mobile map offset needed since map is at bottom
                    const elementPosition = element.offsetTop - headerHeight - mapOffset - 20; // 20px extra padding
                    window.scrollTo({ top: elementPosition, behavior: 'smooth' });
                    history.pushState(null, null, `#${cityId}`);
                } else {
                    console.warn('Element not found for city:', cityId);
                }
            };
            sep2.style.display = 'inline';
        }
    } else {
        // Remove breadcrumb entirely
        if (breadcrumbNav) {
            breadcrumbNav.remove();
        }
        titleContent.classList.add('no-breadcrumb');
    }
}

function smoothZoomToBounds(bounds, maxZoom) {
    if (!mainMap) return;
    
    console.log('smoothZoomToBounds called with maxZoom:', maxZoom);
    
    const currentCenter = mainMap.getCenter();
    const targetCenter = bounds.getCenter();
    const currentZoom = mainMap.getZoom();
    const targetZoom = Math.min(mainMap.getBoundsZoom(bounds, [10, 10]), maxZoom || 18);
    
    // Calculate distance to determine if we need to pan first
    const distance = currentCenter.distanceTo(targetCenter);
    const zoomDifference = Math.abs(currentZoom - targetZoom);
    
    console.log('Pan distance:', Math.round(distance), 'km, Zoom difference:', zoomDifference);
    
    // If it's a significant location change, pan first then zoom
    if (distance > 100000 || zoomDifference > 3) { // > 100km or big zoom change
        console.log('Using pan-then-zoom for large distance/zoom change');
        
        // For very long distances (cross-continental), zoom out first, then pan, then zoom in
        if (distance > 5000000 && currentZoom > 4) { // > 5000km and zoomed in
            console.log('Using zoom-out-pan-zoom-in for intercontinental travel');
            
            // First zoom out to see the journey
            mainMap.setZoom(3, {
                animate: true,
                duration: 0.5
            });
            
            // Then pan while zoomed out
            setTimeout(() => {
                mainMap.panTo(targetCenter, {
                    animate: true,
                    duration: 1.0,
                    easeLinearity: 0.1
                });
            }, 300);
            
            // Finally zoom to target
            setTimeout(() => {
                mainMap.fitBounds(bounds, {
                    animate: true,
                    duration: 0.8,
                    easeLinearity: 0.1,
                    maxZoom: maxZoom,
                    padding: [10, 10]
                });
            }, 1100);
            
        } else {
            // Regular pan-then-zoom for shorter distances
            mainMap.panTo(targetCenter, {
                animate: true,
                duration: 0.8,
                easeLinearity: 0.1
            });
            
            // Then zoom after panning
            setTimeout(() => {
                mainMap.fitBounds(bounds, {
                    animate: true,
                    duration: 0.8,
                    easeLinearity: 0.1,
                    maxZoom: maxZoom,
                    padding: [10, 10]
                });
            }, 500);
        }
        
    } else {
        // For nearby locations, use direct fitBounds
        console.log('Using direct fitBounds for nearby location');
        mainMap.fitBounds(bounds, {
            animate: true,
            duration: 0.8,
            easeLinearity: 0.1,
            maxZoom: maxZoom,
            padding: [10, 10]
        });
    }
}

function zoomToVisibleSection(section) {
    if (section.classList.contains('city-section')) {
        const cityTitle = section.querySelector('.city-title');
        if (cityTitle) {
            const cityName = cityTitle.textContent.replace('üìç ', '').trim();
            zoomToCity(cityName);
        }
    } else if (section.classList.contains('country-section')) {
        zoomToCountry(section.dataset.country);
    } else if (section.classList.contains('continent-section')) {
        const continent = section.dataset.continent;
        if (continent) {
            zoomToRegion(continent);
        }
    }
}

function getMostVisibleSection() {
    // On mobile, account for fixed map at bottom (300px height)
    const isMobile = isMobileDevice();
    const mapHeight = isMobile ? 300 : 0;
    const viewportHeight = window.innerHeight - mapHeight;
    
    // Check city sections first (most specific)
    const citySections = document.querySelectorAll('.city-section');
    for (const section of citySections) {
        const rect = section.getBoundingClientRect();
        // On mobile, check visibility in the scrollable area above the fixed map
        const topThreshold = isMobile ? viewportHeight * 0.3 : window.innerHeight * 0.4;
        const bottomThreshold = isMobile ? viewportHeight * 0.7 : window.innerHeight * 0.6;
        
        if (rect.top < bottomThreshold && rect.bottom > topThreshold) {
            return section;
        }
    }
    
    // Then check country sections
    const countrySections = document.querySelectorAll('.country-section');
    for (const section of countrySections) {
        const rect = section.getBoundingClientRect();
        const topThreshold = isMobile ? viewportHeight * 0.3 : window.innerHeight * 0.4;
        const bottomThreshold = isMobile ? viewportHeight * 0.7 : window.innerHeight * 0.6;
        
        if (rect.top < bottomThreshold && rect.bottom > topThreshold) {
            return section;
        }
    }
    
    // Finally check continent sections
    const continentSections = document.querySelectorAll('.continent-section');
    for (const section of continentSections) {
        const rect = section.getBoundingClientRect();
        const topThreshold = isMobile ? viewportHeight * 0.3 : window.innerHeight * 0.4;
        const bottomThreshold = isMobile ? viewportHeight * 0.7 : window.innerHeight * 0.6;
        
        if (rect.top < bottomThreshold && rect.bottom > topThreshold) {
            return section;
        }
    }
    
    return null;
}

function zoomToRegion(continent) {
    console.log('zoomToRegion called:', { continent, hasMainMap: !!mainMap, isSticky, currentHoveredCard });
    
    if (!mainMap || currentHoveredCard) return;
    
    // Use the actual markers that are already on the map
    if (window.allMarkers && window.allMarkers.length > 0) {
        const relevantMarkers = window.allMarkers.filter(marker => 
            marker.postData && 
            marker.postData.continent.toLowerCase().replace(/\s/g, '-') === continent
        );
        
        console.log('Found relevant markers:', relevantMarkers.length, 'for continent:', continent);
        
        if (relevantMarkers.length > 0) {
            try {
                const group = new L.featureGroup(relevantMarkers);
                const bounds = group.getBounds();
                console.log('Fitting bounds for region:', bounds);
                
                // Only invalidate if we're in the middle of animation
                if (isSticky && mapContainer.classList.contains('animating')) {
                    mainMap.invalidateSize();
                    // Longer delay during animation
                    setTimeout(() => {
                        mainMap.fitBounds(bounds, {
                            padding: [80, 80],
                            maxZoom: 5,
                            animate: true,
                            duration: 0.8
                        });
                    }, 200);
                } else {
                    // Direct fitBounds when not animating
                    mainMap.fitBounds(bounds, {
                        padding: [80, 80],
                        maxZoom: 5,
                        animate: true,
                        duration: 0.8
                    });
                }
            } catch (error) {
                console.error('Error during region zoom:', error);
            }
        }
    }
}

function zoomToCountry(country) {
    console.log('zoomToCountry called:', { country, hasMainMap: !!mainMap, isSticky, currentHoveredCard });
    
    if (!mainMap || currentHoveredCard) return;
    
    // Use the actual markers that are already on the map
    if (window.allMarkers && window.allMarkers.length > 0) {
        const relevantMarkers = window.allMarkers.filter(marker => 
            marker.postData && 
            marker.postData.country === country
        );
        
        console.log('Found relevant markers:', relevantMarkers.length, 'for country:', country);
        
        if (relevantMarkers.length > 0) {
            try {
                const group = new L.featureGroup(relevantMarkers);
                const bounds = group.getBounds();
                console.log('Fitting bounds for country:', bounds);
                
                // Only invalidate if we're in the middle of animation
                if (isSticky && mapContainer.classList.contains('animating')) {
                    mainMap.invalidateSize();
                    // Longer delay during animation
                    setTimeout(() => {
                        mainMap.fitBounds(bounds, {
                            padding: [60, 60],
                            maxZoom: 8,
                            animate: true,
                            duration: 0.8
                        });
                    }, 200);
                } else {
                    // Direct fitBounds when not animating
                    mainMap.fitBounds(bounds, {
                        padding: [60, 60],
                        maxZoom: 8,
                        animate: true,
                        duration: 0.8
                    });
                }
            } catch (error) {
                console.error('Error during country zoom:', error);
            }
        }
    }
}

function zoomToCity(cityName) {
    console.log('zoomToCity called:', { cityName, hasMainMap: !!mainMap, isSticky, currentHoveredCard });
    
    if (!mainMap || currentHoveredCard) return;
    
    // Use the actual markers that are already on the map
    if (window.allMarkers && window.allMarkers.length > 0) {
        const relevantMarkers = window.allMarkers.filter(marker => 
            marker.postData && 
            marker.postData.city === cityName
        );
        
        console.log('Found relevant markers:', relevantMarkers.length, 'for city:', cityName);
        
        if (relevantMarkers.length > 0) {
            try {
                const group = new L.featureGroup(relevantMarkers);
                const bounds = group.getBounds();
                console.log('Fitting bounds for city:', bounds);
                
                // Use appropriate padding and zoom
                const maxZoom = relevantMarkers.length === 1 ? 14 : 12;
                
                // Only invalidate if we're in the middle of animation
                if (isSticky && mapContainer.classList.contains('animating')) {
                    mainMap.invalidateSize();
                    // Longer delay during animation
                    setTimeout(() => {
                        mainMap.fitBounds(bounds, {
                            padding: [50, 50],
                            maxZoom: maxZoom,
                            animate: true,
                            duration: 0.8
                        });
                    }, 200);
                } else {
                    // Direct fitBounds when not animating
                    mainMap.fitBounds(bounds, {
                        padding: [50, 50],
                        maxZoom: maxZoom,
                        animate: true,
                        duration: 0.8
                    });
                }
            } catch (error) {
                console.error('Error during city zoom:', error);
            }
        }
    }
}

// Filter functionality is now integrated into the main initialization above

function zoomToAllPins() {
    if (!mainMap) return;
    
    // Use existing markers if available
    if (window.allMarkers && window.allMarkers.length > 0) {
        console.log('Zooming to all pins using existing markers:', window.allMarkers.length);
        try {
            const group = new L.featureGroup(window.allMarkers);
            mainMap.fitBounds(group.getBounds().pad(0.1));
            return;
        } catch (error) {
            console.error('Error zooming to all markers:', error);
        }
    }
    
    // Fallback to posts
    const validPosts = coffeePostsData.filter(post => 
        post.latitude && post.longitude
    );
    
    if (validPosts.length > 0) {
        try {
            const bounds = L.latLngBounds(validPosts.map(post => [post.latitude, post.longitude]));
            mainMap.fitBounds(bounds.pad(0.1));
        } catch (error) {
            console.error('Error zooming to all pins:', error);
            // Fallback to world view
            mainMap.setView([30, 0], 2);
        }
    } else {
        // No pins, show world view
        mainMap.setView([30, 0], 2);
    }
}

// Ensure initial view shows all pins on page load
window.addEventListener('load', function() {
    setTimeout(() => {
        // Wait a bit for map to be fully initialized, then ensure all pins are visible
        if (window.mainMap && coffeePostsData.length > 0) {
            console.log('Ensuring initial view shows all pins');
            zoomToAllPins();
        }
    }, 2000); // Wait longer to ensure everything is loaded
});

</script>

<style>
/* Content Layout */
.content-wrapper {
    width: 65%;
    /* Always 65% width, no transition needed */
}

.posts-content {
    width: 100%;
}

/* Map Styles */
.main-map {
    width: 100%;
    height: 500px;
    border-radius: 8px;
    border: 1px solid var(--border-color);
    margin: 3rem 0;
    position: relative;
    transition: all 0.3s ease;
    z-index: 1;
}

.main-map.animating {
    position: fixed;
    transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1), 
                width 0.3s cubic-bezier(0.4, 0, 0.2, 1),
                height 0.3s cubic-bezier(0.4, 0, 0.2, 1),
                box-shadow 0.3s cubic-bezier(0.4, 0, 0.2, 1),
                border-radius 0.3s cubic-bezier(0.4, 0, 0.2, 1);
}

/* Latest Stop Section */
.latest-stop-section {
    max-width: 1200px;
    margin: 2rem auto;
    padding: 0 1rem;
}

.latest-stop-container {
    background: var(--card-bg);
    border: 1px solid var(--border-color);
    border-radius: 12px;
    overflow: hidden;
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
    transition: transform 0.2s ease, box-shadow 0.2s ease;
}

.latest-stop-container:hover {
    transform: translateY(-2px);
    box-shadow: 0 8px 24px rgba(0, 0, 0, 0.15);
}

.latest-stop-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 1.5rem 2rem 1rem;
    border-bottom: 1px solid var(--border-color);
    background: linear-gradient(135deg, var(--accent-color) 0%, #B8956B 100%);
    color: white;
}

.latest-stop-header h2 {
    margin: 0;
    font-size: 1.5rem;
    font-weight: 600;
    text-transform: uppercase;
    letter-spacing: 1px;
}

.latest-stop-date {
    font-size: 0.9rem;
    opacity: 0.9;
    font-weight: 300;
}

.latest-stop-card {
    display: flex;
    gap: 2rem;
    padding: 2rem;
    text-decoration: none;
    color: inherit;
    transition: background-color 0.2s ease;
}

.latest-stop-card:hover {
    background: rgba(212, 165, 116, 0.05);
}

.latest-stop-image {
    flex: 0 0 200px;
    height: 150px;
    border-radius: 8px;
    overflow: hidden;
    background: var(--accent-color);
}

.latest-stop-image img {
    width: 100%;
    height: 100%;
    object-fit: cover;
    transition: transform 0.3s ease;
}

.latest-stop-card:hover .latest-stop-image img {
    transform: scale(1.05);
}

.latest-stop-content {
    flex: 1;
    display: flex;
    flex-direction: column;
    gap: 0.75rem;
}

.latest-stop-title {
    font-size: 1.5rem;
    font-weight: 600;
    margin: 0;
    color: var(--accent-color);
    line-height: 1.2;
}

.latest-stop-location {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    font-size: 1rem;
    color: var(--text-light);
    font-weight: 500;
}

.location-icon {
    font-size: 0.9rem;
}

.latest-stop-rating {
    font-size: 1.1rem;
    color: var(--accent-color);
    line-height: 1;
}

.latest-stop-description {
    flex: 1;
    margin: 0;
    color: var(--text-light);
    line-height: 1.6;
    font-size: 0.95rem;
}

.latest-stop-cta {
    font-weight: 600;
    color: var(--accent-color);
    font-size: 0.9rem;
    text-transform: uppercase;
    letter-spacing: 0.5px;
    margin-top: 0.5rem;
    transition: transform 0.2s ease;
}

.latest-stop-card:hover .latest-stop-cta {
    transform: translateX(4px);
}

/* Mobile responsive */
@media (max-width: 768px) {
    .latest-stop-section {
        margin: 1rem auto;
        padding: 0 0.5rem;
    }
    
    .latest-stop-header {
        padding: 1rem 1.5rem 0.75rem;
        flex-direction: column;
        align-items: flex-start;
        gap: 0.5rem;
    }
    
    .latest-stop-header h2 {
        font-size: 1.3rem;
    }
    
    .latest-stop-date {
        font-size: 0.85rem;
    }
    
    .latest-stop-card {
        flex-direction: column;
        gap: 1.5rem;
        padding: 1.5rem;
    }
    
    .latest-stop-image {
        flex: none;
        width: 100%;
        height: 200px;
    }
    
    .latest-stop-title {
        font-size: 1.3rem;
    }
}

/* Content layout for desktop - default 65% width to leave room for map */
.content-wrapper {
    width: 100%;
    transition: width 0.6s cubic-bezier(0.4, 0, 0.2, 1);
}

.posts-content {
    width: 100%;
}

/* Desktop layout and map animation */
@media (min-width: 1024px) {
    .content-wrapper {
        width: 65%;
        margin: 0 auto 0 0; /* Left align the content */
        transition: width 0.6s cubic-bezier(0.4, 0, 0.2, 1);
    }
    
    /* Make latest stop and filters also 65% width to match content */
    .latest-stop-section {
        max-width: 65%;
        margin: 2rem auto 2rem 0; /* Left align with content */
    }
    
    .filter-controls {
        max-width: 65%;
        margin: 0 auto 2rem 0; /* Left align with content */
    }
    
    .with-sidebar .latest-stop-section {
        margin-right: 2rem;
    }
    
    .with-sidebar .filter-controls {
        margin-right: 2rem;
    }
}


@media (max-width: 768px) {
    .filter-controls {
        margin: 2rem 0; /* Normal margin for filter controls */
    }
    
    .content-wrapper {
        width: 100%;
        padding-bottom: 320px; /* Add bottom padding for fixed map */
    }
    
    #map {
        /* Anchor map to bottom on mobile */
        position: fixed !important;
        bottom: 0 !important;
        left: 0 !important;
        right: 0 !important;
        width: 100% !important;
        height: 300px !important;
        z-index: 1000 !important;
        margin: 0 !important;
        border: none !important;
        border-radius: 0 !important;
        box-shadow: 0 -4px 12px rgba(0,0,0,0.3);
    }
    
    .main-content {
        display: flex;
        flex-direction: column;
    }
}

/* Mobile responsive section styling */
@media (max-width: 768px) {
    .country-section {
        margin: 1rem -2rem 2rem -2rem; /* Full bleed */
        border-left: none;
        border-bottom: 3px solid var(--accent-color);
        padding: 0 2rem 1rem 2rem;
    }
    
    .country-title {
        font-size: 1.6rem;
    }
    
    .city-section {
        margin: 1rem -2rem;
        padding: 0 2rem;
        border-left: none;
        border-bottom: 1px solid var(--border-color);
    }
    
    .city-title {
        font-size: 1.2rem;
    }
    
    .continent-title {
        font-size: 1.8rem;
        margin: 2rem -2rem;
        padding: 0 2rem;
    }
    
    /* Make coffee cards full bleed on mobile */
    .coffee-post {
        margin-left: -2rem;
        margin-right: -2rem;
        border-radius: 0;
    }
}

/* Section link styling */
.section-link {
    color: inherit;
    text-decoration: none;
    transition: color 0.2s ease;
}

.section-link:hover {
    color: var(--accent-color);
}

/* Site title container for breadcrumb layout */
.site-title-container {
    display: flex;
    flex-direction: column;
    align-items: center;
}

/* Breadcrumb navigation styling - as subheading */
.breadcrumb-nav {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    font-size: 0.75rem;
    white-space: nowrap;
    opacity: 0;
    transition: opacity 0.3s ease, transform 0.3s ease;
    transform: translateY(-5px);
    margin-top: 0.2rem;
}

.breadcrumb-nav.visible {
    opacity: 1;
    transform: translateY(0);
}

.breadcrumb-link {
    color: var(--text-light);
    text-decoration: none;
    transition: color 0.2s ease;
    font-weight: 400;
}

.breadcrumb-link:hover {
    color: var(--accent-color);
}

.breadcrumb-separator {
    color: var(--accent-color);
    font-size: 0.8rem;
    font-weight: 300;
    opacity: 0.8;
}

@media (max-width: 768px) {
    .breadcrumb-nav {
        font-size: 0.65rem;
        gap: 0.3rem;
    }
    
    .breadcrumb-separator {
        font-size: 0.7rem;
    }
}

.coffee-grid {
    position: relative;
    z-index: 1;
}

.region-section {
    position: relative;
    z-index: 1;
}

.filter-controls {
    display: flex;
    justify-content: center;
    gap: 1rem;
    margin: 3rem 0;
    flex-wrap: wrap;
    position: relative;
    z-index: 100; /* Ensure buttons are clickable above other content */
}

.filter-btn {
    padding: 0.5rem 1.5rem;
    background: rgba(26, 26, 26, 0.8);
    backdrop-filter: blur(10px);
    border: 1px solid var(--border-color);
    border-radius: 25px;
    color: var(--primary-color);
    cursor: pointer;
    transition: all 0.3s ease;
    font-family: inherit;
    font-size: 0.9rem;
    letter-spacing: 0.5px;
}

.filter-btn:hover {
    background: rgba(212, 165, 116, 0.2);
    border-color: var(--accent-color);
}

.filter-btn.active {
    background: var(--accent-color);
    color: var(--bg-color);
    border-color: var(--accent-color);
}

.no-posts {
    text-align: center;
    padding: 4rem 2rem;
    color: var(--text-light);
}

.no-posts h2 {
    font-weight: 300;
    margin-bottom: 1rem;
}

.continent-title {
    font-size: 2.2rem;
    font-weight: 300;
    color: var(--accent-color);
    margin: 3rem 0 2rem 0;
    text-align: center;
    letter-spacing: -0.5px;
}

.country-section {
    margin: 2rem 0;
    border-left: 3px solid var(--accent-color);
    padding-left: 2rem;
}

.country-title {
    font-size: 1.8rem;
    font-weight: 400;
    color: var(--primary-color);
    margin: 1.5rem 0 1rem 0;
    opacity: 0.9;
}

.city-section {
    margin: 1.5rem 0;
    padding-left: 1rem;
    border-left: 2px solid var(--border-color);
}

.city-title {
    font-size: 1.3rem;
    font-weight: 500;
    color: var(--text-light);
    margin: 1rem 0 1rem 0;
    display: flex;
    align-items: center;
    gap: 0.5rem;
}

@media (max-width: 768px) {
    .filter-controls {
        padding: 0 1rem;
    }
    
    .filter-btn {
        font-size: 0.85rem;
        padding: 0.4rem 1rem;
    }
    
    /* Mobile: remove section borders, zero padding, cards get rounded rects */
    .continent-section,
    .country-section,
    .city-section {
        border: none !important;
        border-left: none !important;
        padding: 0 !important;
        margin: 0 !important;
        background: var(--bg-color);
    }
    
    /* Section headings get padding to align with cards */
    .continent-title,
    .country-title,
    .city-title {
        padding: 0 1em !important;
        margin: 1em 0 !important;
    }
    
    .coffee-card {
        border-radius: 8px !important;
        margin: 1em !important;
    }
}

/* Coming Soon Sections */
.coming-soon {
    padding: 4rem 2rem;
    text-align: center;
    background: linear-gradient(135deg, rgba(212, 165, 116, 0.05) 0%, rgba(212, 165, 116, 0.1) 100%);
    border-radius: 12px;
    margin: 2rem 0;
    border: 2px dashed rgba(212, 165, 116, 0.2);
}

.coming-soon-content {
    max-width: 400px;
    margin: 0 auto;
}

.coming-soon-emoji {
    font-size: 4rem;
    display: block;
    margin-bottom: 1rem;
    animation: float 3s ease-in-out infinite;
}

.coming-soon h2 {
    color: var(--accent-color);
    margin-bottom: 1rem;
    font-size: 2rem;
    font-weight: 300;
}

.coming-soon p {
    color: var(--text-secondary);
    font-size: 1.1rem;
    font-style: italic;
}

@keyframes float {
    0%, 100% { transform: translateY(0); }
    50% { transform: translateY(-10px); }
}

@media (max-width: 768px) {
    .coming-soon {
        padding: 3rem 1.5rem;
    }
    
    .coming-soon-emoji {
        font-size: 3rem;
    }
    
    .coming-soon h2 {
        font-size: 1.5rem;
    }
    
    .coming-soon p {
        font-size: 1rem;
    }
}

</style>